snippet snippets "Snippets for C++"
	/*
	#Basics#
	beg
	debug
	dbg
	rng
	power

	#Data Structures#
	mstack
	mqueue
	dsu
	dsu_rollback
	sparse
	sparse2d
	fenwick1
	fenwick2
	fenwick3
	segtree
	segtreelazy
	triestr
	triebit
	mo
	segtree2d
	ordered_set
	treap

	#Graph#
	dfs
	bfs
	topsort
	bipartite
	ucycle
	dcycle
	bridges
	artpoints
	bridgetree
	scc
	centroids
	euler_tour
	floyd
	dijkstra
	bellman
	spfa
	prim
	kruskal
	twosat	
	flow1
	flow2

	#String#
	split
	strip
	hash
	zfunction
	manacher
	suffix_array

	#Number Theory#
	exgcd
	sieve
	linear_sieve

	#Math#
	mint
	matrix
	segmented_sieve
	miller_rabin
	convert_base

	#Geometry#
	move
	geo2d

	#Miscellaneous#
	mex
	mex2
	arpa
	*/
	${0}

snippet beg "Start Template"
	#include <bits/stdc++.h>
	using namespace std;

	void solve() {
		${0}	
	}

	int32_t main() {
		ios_base::sync_with_stdio(false);
		cin.tie(nullptr);

		int t = 1;
		$1cin >> t;

		while (t--) {
			solve();
		}

		return 0;
	}

snippet debug "Debug Template"
	#define dbg(...) cerr << debug_util::outer << __LINE__ << ": [", \
					 debug_util::printer(#__VA_ARGS__, __VA_ARGS__), \
					 cerr << debug_util::outer << "]\n" << debug_util::reset

	namespace debug_util {
		const string WHITE = "\033[0;m";
		const string RED = "\033[0;31m";
		const string BLUE = "\033[0;34m";
		const string GREEN = "\033[0;32m";

		bool colored_output = isatty(fileno(stderr)); 
		string reset = colored_output ? WHITE : "";
		string outer = colored_output ? RED : "";
		string var_name = colored_output ? BLUE : "";
		string var_value = colored_output ? GREEN : "";

		template <typename T>
		concept is_iterable = requires(T&& x) { begin(x); } && !is_same_v<remove_cvref_t<T>, string>;

		template <typename T>
		void print(T* p);

		void print(const char* x) { cerr << x; }
		void print(char x) { cerr << "\'" << x << "\'"; }
		void print(string x) { cerr << "\"" << x << "\""; }
		void print(bool x) { cerr << (x ? "true" : "false"); }

		// Print vector<bool>, stl optimizes this by using _Bit_reference
		void print(vector<bool>& v) { 
			int f = 0;
			cerr << "{";
			for (auto&& i : v) {
				cerr << (f++ ? ", " : "") << (i ? "true" : "false");
			}
			cerr << "}";
		}

		template <typename T>
		void print(T&& x) {
			if constexpr (is_iterable<T>) {
				if (size(x) && is_iterable<decltype(*(begin(x)))>) { 
					// Iterable inside Iterable
					int f = 0;
					int w = max(0, (int)log10(size(x) - 1)) + 2;
					cerr << "\n~~~~~~~~\n";
					for (auto&& i : x) {
						cerr << setw(w) << left << f++, print(i), cerr << "\n";
					}
					cerr << "~~~~~~~~\n";
				} else { 
					// Normal Iterable
					int f = 0;
					cerr << "{";
					for (auto&& i : x) {
						cerr << (f++ ? ", " : ""), print(i);
					}
					cerr << "}";
				}
			} else if constexpr (requires { x.pop(); }) {
				auto tmp = x;
				int f = 0;
				cerr << "{";
				if constexpr (requires { x.top(); }) {
					// Stack, Priority Queue
					while (!tmp.empty()) {
						cerr << (f++ ? ", " : ""), print(tmp.top()), tmp.pop();
					}
				} else {
					// Queue
					while (!tmp.empty()) {
						cerr << (f++ ? ", " : ""), print(tmp.front()), tmp.pop();
					}
				}
				cerr << "}";
			} else if constexpr (requires { x.first; x.second; }) {
				// Pair
				cerr << "(", print(x.first), cerr << ", ", print(x.second), cerr << ")";
			} else if constexpr (requires { get<0>(x); }) {
				// Tuple
				int f = 0;
				cerr << "("; 
				apply([&f](auto... args) {
					((cerr << (f++ ? ", " : ""), print(args)), ...);
				}, x);
				cerr << ")";
			} else {
				cerr << x;
			}
		}

		// Print pointers address and, if not null, pointed value
		template <typename T>
		void print(T* p) {
			if (!p) {
				cerr << "(nullptr)";
			} else {
				cerr << "(" << p << ") -> ";
				print(*p);
			}
		}

		template <typename T, typename... V>
		void printer(const char* names, T&& head, V&&... tail) {
			int i = 0;
			for (int bracket = 0; names[i] != '\0' && (names[i] != ',' || bracket != 0); i++) {
				if (names[i] == '(' || names[i] == '<' || names[i] == '{') {
					bracket++;
				} else if (names[i] == ')' || names[i] == '>' || names[i] == '}') {
					bracket--;
				}
			}
			cerr << var_name;
			cerr.write(names, i) << outer << " = " << var_value;
			print(head);
			if constexpr (sizeof...(tail)) {
				cerr << outer << " ||";
				printer(names + i + 1, tail...);
			}
		}
	}
	${0}

snippet dbg "Debug Headers"
	#ifdef DEBUG
	#include "/home/mohammad/code/debug.h"
	#else
	#define dbg(...)
	#endif
	${0}

snippet rng "Random Generator"
	mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
	#define uid(a, b) uniform_int_distribution<int64_t>(a, b)(rng)
	${0}

snippet power "Binary Exponentiation, O(log(b))
	template <typename T>
	T power(T a, int64_t b, int64_t m) {
		assert(b >= 0);
		T res{1};
		while (b) {
			if (b & 1) {
				res = res * a % m;
			}
			a = a * a % m;
			b >>= 1;
		}
		return res;
	}
	${0}

snippet mstack "Minimum Stack, O(1)" 
	template <typename T, typename Compare = less<T>>
	struct MStack {
		stack<pair<T, T>> st;
		Compare cmp = Compare();
		
		void push(const T& x) {
			T mn = st.empty() ? x : min(x, st.top().second, cmp);
			st.emplace(x, mn);
		}
		void pop() {
			st.pop();
		}
		T top() const {
			return st.top().first;
		}
		T get() const {
			return st.top().second;
		}
		int size() const {
			return st.size();
		}
		bool empty() const {
			return st.empty();
		}
	};
	${0}

snippet mqueue "Minimum Queue, O(1)" 
	template <typename T, typename Compare = less<T>>
	struct MQueue {
		stack<pair<T, T>> st1, st2;
		Compare cmp = Compare();
		
		void push(const T& x) {
			T mn = st1.empty() ? x : min(x, st1.top().second, cmp);
			st1.emplace(x, mn);
		}
		void pop() {
			if (st2.empty()) {
				while (!st1.empty()) {
					T x = st1.top().first;
					T mn = st2.empty() ? x : min(x, st2.top().second, cmp);
					st1.pop();
					st2.emplace(x, mn);
				}
			}
			st2.pop();
		}
		T front() {
			if (st2.empty()) {
				while (!st1.empty()) {
					T x = st1.top().first;
					T mn = st2.empty() ? x : min(x, st2.top().second, cmp);
					st1.pop();
					st2.emplace(x, mn);
				}
			}
			return st2.top().first;
		}
		T get() const {
			if (st1.empty() || st2.empty()) {
				return st1.empty() ? st2.top().second : st1.top().second;
			}
			return min(st1.top().second, st2.top().second, cmp);
		}
		int size() const {
			return st1.size() + st2.size();
		}
		bool empty() const {
			return st1.empty() && st2.empty();
		}
	};
	${0}

snippet dsu "Disjoint Set Union, O(alpha(n))"
	struct DSU {
		int c; // components
		vector<int> par, sz;
		
		DSU() : c(0) {}
		DSU(int n) {
			init(n);
		}

		void init(int n) {
			c = n;
			par.resize(n);
			iota(par.begin(), par.end(), 0);
			sz.assign(n, 1);
		}

		int find(int a) {
			return (par[a] == a ? a : (par[a] = find(par[a])));
		}
		bool merge(int a, int b) {
			if ((a = find(a)) == (b = find(b))) {
				return false;
			}
			if (sz[a] > sz[b]) {
				swap(a, b);
			}
			c--;
			par[a] = b;
			sz[b] += sz[a];
			return true;
		}
	};
	${0}

snippet dsu_rollback "DSU with Rollback, O(log(n))"
	struct DSU {
		int c; // components
		vector<int> par, sz, mark;
		vector<pair<int&, int>> history;
		
		DSU() : c(0) {}
		DSU(int n) {
			init(n);
		}

		void init(int n) {
			c = n;
			par.resize(n);
			iota(par.begin(), par.end(), 0);
			sz.assign(n, 1);
			mark.clear();
			history.clear();
		}

		int find(int a) {
			return (par[a] == a ? a : find(par[a]));
		}
		bool merge(int a, int b) {
			mark.push_back(history.size());
			if ((a = find(a)) == (b = find(b))) {
				return false;
			}
			if (sz[a] > sz[b]) {
				swap(a, b);
			}
			history.emplace_back(c, c);
			history.emplace_back(par[a], par[a]);
			history.emplace_back(sz[b], sz[b]);
			c--;
			par[a] = b;
			sz[b] += sz[a];
			return true;
		}
		void undo() {
			if (mark.empty()) {
				return;
			}
			while ((int)history.size() > mark.back()) {
				history.back().first = history.back().second;
				history.pop_back();
			}
			mark.pop_back();
		}
	};
	${0}

snippet sparse "Sparse Table for RMQ, build -> O(n*log(n)), query -> O(1)"
	template <typename T, typename Compare = less<T>>
	struct SparseTable {
		int n;
		vector<vector<T>> t;
		Compare cmp = Compare();

		SparseTable() : n(0) {}
		SparseTable(const vector<T>& v) {
			build(v);
		}

		void build(const vector<T>& v) {
			n = v.size();
			const int lg = __bit_width(n);
			t.assign(n, vector<T>(lg));

			for (int i = 0; i < n; i++) {
				t[i][0] = v[i];
			}
			for (int k = 1; k < lg; k++) {
				for (int i = 0; i + (1 << k) - 1 < n; i++) {
					t[i][k] = min(t[i][k - 1], t[i + (1 << (k - 1))][k - 1], cmp);
				}
			}
		}
		T get(int l, int r) const { 
			assert(l >= 0 && l <= r && r < n);
			int k = __bit_width(r - l + 1) - 1;
			return min(t[l][k], t[r - (1 << k) + 1][k], cmp);
		}
	};
	${0}

snippet sparse2d "Sparse Table 2D for RMQ build -> O(n*m*log(n)*log(m)), query -> O(1)"
	template <typename T, typename Compare = less<T>>
	struct SparseTable2D {
		int n, m;
		vector<vector<vector<vector<T>>>> t;
		Compare cmp = Compare();

		SparseTable2D() : n(0), m(0) {}
		SparseTable2D(const vector<vector<T>>& v) {
			build(v);
		}

		void build(const vector<vector<T>>& v) {
			n = v.size();
			m = v[0].size();
			const int lg_n = __bit_width(n);
			const int lg_m = __bit_width(m);
			t.assign(n, vector(m, vector(lg_n, vector<T>(lg_m))));

			for (int i = 0; i < n; i++) {
				for (int j = 0; j < m; j++) {
					t[i][j][0][0] = v[i][j];
				}
			}
			for (int k1 = 0; k1 < lg_n; k1++) {
				for (int k2 = 0; k2 < lg_m; k2++) {
					if (k1 + k2 == 0) {
						continue;
					}
					for (int i = 0; i + (1 << k1) - 1 < n; i++) {
						for (int j = 0; j + (1 << k2) - 1 < m; j++) {
							if (!k1) {
								t[i][j][k1][k2] = min(t[i][j][k1][k2 - 1], t[i][j + (1 << (k2 - 1))][k1][k2 - 1], cmp);
							} else {
								t[i][j][k1][k2] = min(t[i][j][k1 - 1][k2], t[i + (1 << (k1 - 1))][j][k1 - 1][k2], cmp);
							}
						}
					}
				}
			}
		}
		T get(int l1, int r1, int l2, int r2) const { 
			assert(l1 >= 0 && l1 <= r1 && r1 < n);
			assert(l2 >= 0 && l2 <= r2 && r2 < m);
			int k1 = __bit_width(r1 - l1 + 1) - 1;
			int k2 = __bit_width(r2 - l2 + 1) - 1;
			return min({t[l1][l2][k1][k2],
						t[r1 - (1 << k1) + 1][l2][k1][k2],
						t[l1][r2 - (1 << k2) + 1][k1][k2],
						t[r1 - (1 << k1) + 1][r2 - (1 << k2) + 1][k1][k2]}, cmp);
		}
	};
	${0}

snippet fenwick1 "Point Update & Range Query, O(log(n))"
	template <typename T>
	struct FenwickTree {
		int n;
		vector<T> f;
		
		FenwickTree() {}
		FenwickTree(int _n) : n(_n) {
			f.assign(n, T{});
		}
		// O(n) Construction
		FenwickTree(const vector<T> &v) {
			n = v.size();
			f.assign(v.begin(), v.end());;
			for (int i = 0; i < n; i++) {
				int r = i | (i + 1);
				if (r < n) {
					f[r] += f[i];
				}
			}
		}
		
		void modify(int x, const T &v) {
			assert(x >= 0 && x < n);
			for (int i = x; i < n; i = i | (i + 1)) {
				f[i] += v;
			}
		}
		T get(int x) {
			T res{};
			for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {
				res += f[i];
			}
			return res;
		}
		T get(int l, int r) {
			assert(l >= 0 && l <= r && r < n);
			return get(r) - get(l - 1);
		}
    	// Lower bound on prefix sum array (every a[i] must be non-negative)
		int select(const T &k) {
			T sum{};
			int x = 0, pw = __bit_floor(unsigned(n));;
			for (int len = pw; len > 0; len >>= 1) {
				if (x + len <= n && sum + f[x + len - 1] < k) {
					sum += f[x + len - 1];
					x += len;
				}
			}
			assert(x >= 0 && x <= n);
			return x;
		}
	};
	${0}

snippet fenwick2 "Range Update & Point Query, O(log(n))"
	template <typename T>
	struct FenwickTree { 
		int n;
		vector<T> f;
		
		FenwickTree() {}
		FenwickTree(int _n) : n(_n) {
			f.assign(n, T{});
		}
		FenwickTree(const vector<T> &v) {
			n = v.size();
			f.assign(n, T{});
			for (int i = 0; i < n; i++) {
				modify(i, i, v[i]);
			}
		}

		void modify(int x, const T &v) {
			for (int i = x; i < n; i = i | (i + 1)) {
				f[i] += v;
			}
		}
		void modify(int l, int r, const T &v) {
			assert(l >= 0 && l <= r && r < n);
			modify(l, v);
			modify(r + 1, -v);
		}
		T get(int x) {
			assert(x >= 0 && x < n);
			T res = 0;
			for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {
				res += f[i];
			}
			return res;
		}
	};
	${0}

snippet fenwick3 "Range Update & Range Query, O(log(n))"
	template <typename T>
	struct FenwickTree {
		int n;
		vector<T> f_mul, f_add;
		
		FenwickTree() {}
		FenwickTree(int _n) : n(_n) {
			f_mul.assign(n, T{});
			f_add.assign(n, T{});
		}
		FenwickTree(const vector<T> &v) {
			n = v.size();
			f_mul.assign(n, T{});
			f_add.assign(n, T{});
			for (int i = 0; i < n; i++) {
				modify(i, i, v[i]);
			}
		}

		void add(int x, T mul, T add) {
			for (int i = x; i < n; i = i | (i + 1)) {
				f_mul[i] += mul;
				f_add[i] += add;
			}
		}
		void modify(int l, int r, const T &v) {
			assert(l >= 0 && l <= r && r < n);
			add(l, v, -v * (l - 1));
			add(r, -v, v * r);
		}
		T get(int x) {
			T mul{}, add{};
			for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {
				mul += f_mul[i];
				add += f_add[i];
			}
			return mul * x + add;
		}
		T get(int l, int r) {
			assert(l >= 0 && l <= r && r < n);
			return get(r) - get(l - 1);
		}
	};
	${0}

snippet segtree "Segment Tree, build -> O(n), update & query -> O(log(n))"
	struct SegmentTree {
		struct Node {
			int64_t sum = 0;
			int mn = 2e9, cnt = 0;

			template <typename M>
			void init(const M &v) {
				sum = mn = v;
				cnt = 1;
			}
		};

		int n;
		vector<Node> tree;

		Node merge(const Node &a, const Node &b) const {
			Node res;
			res.sum = a.sum + b.sum;
			res.mn = min(a.mn, b.mn);
			res.cnt = (res.mn == a.mn ? a.cnt : 0) + (res.mn == b.mn ? b.cnt : 0);
			return res;
		}

		inline void pull(int x) {
			tree[x] = merge(tree[2 * x], tree[2 * x + 1]);
		}

		void build(int x, int l, int r) {
			if (l == r) {
				return;
			}
			int m = (l + r) / 2;
			build(2 * x, l, m);
			build(2 * x + 1, m + 1, r);
			pull(x);
		}

		template <typename M>
		void build(int x, int l, int r, const vector<M> &v) {
			if (l == r) {
				tree[x].init(v[l]);
				return;
			}
			int m = (l + r) / 2;
			build(2 * x, l, m, v);
			build(2 * x + 1, m + 1, r, v);
			pull(x);
		}

		template <typename M>
		void modify(int x, int l, int r, int p, const M &v) {
			if (l == r) {
				tree[x].init(v);
				return;
			}
			int m = (l + r) / 2;
			if (p <= m) {
				modify(2 * x, l, m, p, v);
			}
			else {
				modify(2 * x + 1, m + 1, r, p, v);
			}
			pull(x);
		}
		
		Node get(int x, int l, int r, int ll, int rr) {
			if (l > rr || r < ll) {
				return Node();
			}
			if (l >= ll && r <= rr) {
				return tree[x];
			}
			int m = (l + r) / 2;
			return merge(get(2 * x, l, m, ll, rr), get(2 * x + 1, m + 1, r, ll, rr));
		}

		int find_first_knowingly(int x, int l, int r, const function<bool(const Node&)> &f) {
			if (l == r) {
				return l;
			}
			int m = (l + r) / 2;
			if (f(tree[2 * x])) {
				return find_first_knowingly(2 * x, l, m, f);
			} 
			return find_first_knowingly(2 * x + 1, m + 1, r, f);
		}

		int find_first(int x, int l, int r, int ll, int rr, const function<bool(const Node&)> &f) {
			if (l > rr || r < ll) {
				return -1;
			}
			if (l >= ll && r <= rr) {
				if (!f(tree[x])) {
					return -1;
				}
				return find_first_knowingly(x, l, r, f);
			}
			int m = (l + r) / 2;
			int res = find_first(2 * x, l, m, ll, rr, f);
			if (res == -1) {
				res = find_first(2 * x + 1, m + 1, r, ll, rr, f);
			}
			return res;
		}

		int find_last_knowingly(int x, int l, int r, const function<bool(const Node&)> &f) {
			if (l == r) {
				return l;
			}
			int m = (l + r) / 2;
			if (f(tree[2 * x + 1])) {
				return find_last_knowingly(2 * x + 1, m + 1, r, f);
			} 
			return find_last_knowingly(2 * x, l, m, f);
		}

		int find_last(int x, int l, int r, int ll, int rr, const function<bool(const Node&)> &f) {
			if (l > rr || r < ll) {
				return -1;
			}
			if (l >= ll && r <= rr) {
				if (!f(tree[x])) {
					return -1;
				}
				return find_last_knowingly(x, l, r, f);
			}
			int m = (l + r) / 2;
			int res = find_last(2 * x + 1, m + 1, r, ll, rr, f);
			if (res == -1) {
				res = find_last(2 * x, l, m, ll, rr, f);
			}
			return res;
		}

		SegmentTree(int _n) : n(_n) {
			assert(n > 0);
			tree.resize(4 * n);
			build(1, 0, n - 1);
		}

		template <typename M>
		SegmentTree(const vector<M> &v) {
			n = v.size();
			assert(n > 0);
			tree.resize(4 * n);
			build(1, 0, n - 1, v);
		}

		template <typename M>
		void modify(int p, const M &v) {
			assert(p >= 0 && p < n);
			modify(1, 0, n - 1, p, v);
		}

		Node get(int ll, int rr) {
			assert(ll >= 0 && ll <= rr && rr < n);
			return get(1, 0, n - 1, ll, rr);
		}

		Node get(int p) {
			assert(p >= 0 && p < n);
			return get(1, 0, n - 1, p, p);
		}

		// find_first and find_last find first/last element satisfy f
    	// auto f = [&](const auto &node) { return node.mn <= 0; };

		int find_first(int ll, int rr, const function<bool(const Node&)> &f) {
			assert(ll >= 0 && ll <= rr && rr < n);
			return find_first(1, 0, n - 1, ll, rr, f);
		}

		int find_last(int ll, int rr, const function<bool(const Node&)> &f) {
			assert(ll >= 0 && ll <= rr && rr < n);
			return find_last(1, 0, n - 1, ll, rr, f);
		}
	};
	${0}

snippet segtreelazy "Segment Tree with Lazy Propagation, build -> O(n), update & query -> O(log(n))"
	struct SegmentTreeLazy {
		struct Node {
			int64_t sum = 0, mn = 4e18, cnt = 0;
			int64_t add = 0;

			template <typename M>
			void init(const M &v) {
				sum = mn = v;
				cnt = 1;
				add = 0;
			}
			template <typename M>
			void apply([[maybe_unused]] int l, [[maybe_unused]] int r, const M &v) {
				sum += (int64_t)v * (r - l + 1);
				mn += v;
				add += v;
			}
		};

		int n;
		vector<Node> tree;

		Node merge(const Node &a, const Node &b) const {
			Node res;
			res.sum = a.sum + b.sum;
			res.mn = min(a.mn, b.mn);
			res.cnt = (res.mn == a.mn ? a.cnt : 0) + (res.mn == b.mn ? b.cnt : 0);
			return res;
		}

		inline void pull(int x) {
			tree[x] = merge(tree[2 * x], tree[2 * x + 1]);
		}

		inline void push(int x, int l, int r) {
			if (tree[x].add != 0 && l != r) {
				int m = (l + r) / 2;
				tree[2 * x].apply(l, m, tree[x].add);
				tree[2 * x + 1].apply(m + 1, r, tree[x].add);
				tree[x].add = 0;
			}
		}

		void build(int x, int l, int r) {
			if (l == r) {
				return;
			}
			int m = (l + r) / 2;
			build(2 * x, l, m);
			build(2 * x + 1, m + 1, r);
			pull(x);
		}

		template <typename M>
		void build(int x, int l, int r, const vector<M> &v) {
			if (l == r) {
				tree[x].init(v[l]);
				return;
			}
			int m = (l + r) / 2;
			build(2 * x, l, m, v);
			build(2 * x + 1, m + 1, r, v);
			pull(x);
		}

		template <typename M>
		void modify(int x, int l, int r, int ll, int rr, const M &v) {
			if (l > rr || r < ll) {
				return;
			}
			if (l >= ll && r <= rr) {
				tree[x].apply(l, r, v);
				return;
			}
			push(x, l, r);
			int m = (l + r) / 2;
			modify(2 * x, l, m, ll, rr, v);
			modify(2 * x + 1, m + 1, r, ll, rr, v);
			pull(x);
		}

		Node get(int x, int l, int r, int ll, int rr) {
			if (l > rr || r < ll) {
				return Node();
			}
			if (l >= ll && r <= rr) {
				return tree[x];
			}
			push(x, l, r);
			int m = (l + r) / 2;
			return merge(get(2 * x, l, m, ll, rr), get(2 * x + 1, m + 1, r, ll, rr));
		}

		int find_first_knowingly(int x, int l, int r, const function<bool(const Node&)> &f) {
			if (l == r) {
				return l;
			}
			push(x, l, r);
			int m = (l + r) / 2;
			if (f(tree[2 * x])) {
				return find_first_knowingly(2 * x, l, m, f);
			} 
			return find_first_knowingly(2 * x + 1, m + 1, r, f);
		}

		int find_first(int x, int l, int r, int ll, int rr, const function<bool(const Node&)> &f) {
			if (l > rr || r < ll) {
				return -1;
			}
			if (l >= ll && r <= rr) {
				if (!f(tree[x])) {
					return -1;
				}
				return find_first_knowingly(x, l, r, f);
			}
			push(x, l, r);
			int m = (l + r) / 2;
			int res = find_first(2 * x, l, m, ll, rr, f);
			if (res == -1) {
				res = find_first(2 * x + 1, m + 1, r, ll, rr, f);
			}
			return res;
		}

		int find_last_knowingly(int x, int l, int r, const function<bool(const Node&)> &f) {
			if (l == r) {
				return l;
			}
			push(x, l, r);
			int m = (l + r) / 2;
			if (f(tree[2 * x + 1])) {
				return find_last_knowingly(2 * x + 1, m + 1, r, f);
			} 
			return find_last_knowingly(2 * x, l, m, f);
		}

		int find_last(int x, int l, int r, int ll, int rr, const function<bool(const Node&)> &f) {
			if (l > rr || r < ll) {
				return -1;
			}
			if (l >= ll && r <= rr) {
				if (!f(tree[x])) {
					return -1;
				}
				return find_last_knowingly(x, l, r, f);
			}
			push(x, l, r);
			int m = (l + r) / 2;
			int res = find_last(2 * x + 1, m + 1, r, ll, rr, f);
			if (res == -1) {
				res = find_last(2 * x, l, m, ll, rr, f);
			}
			return res;
		}

		SegmentTreeLazy(int _n) : n(_n) {
			assert(n > 0);
			tree.resize(4 * n);
			build(1, 0, n - 1);
		}

		template <typename M>
		SegmentTreeLazy(const vector<M> &v) {
			n = v.size();
			assert(n > 0);
			tree.resize(4 * n);
			build(1, 0, n - 1, v);
		}

		template <typename M>
		void modify(int ll, int rr, const M &v) {
			assert(ll >= 0 && ll <= rr && rr < n);
			modify(1, 0, n - 1, ll, rr, v);
		}

		Node get(int ll, int rr) {
			assert(ll >= 0 && ll <= rr && rr < n);
			return get(1, 0, n - 1, ll, rr);
		}

		Node get(int p) {
			assert(p >= 0 && p < n);
			return get(1, 0, n - 1, p, p);
		}

		// find_first and find_last find first/last element satisfy f
		// auto f = [&](const auto &node) { return node.mn <= 0; };

		int find_first(int ll, int rr, const function<bool(const Node&)> &f) {
			assert(ll >= 0 && ll <= rr && rr < n);
			return find_first(1, 0, n - 1, ll, rr, f);
		}

		int find_last(int ll, int rr, const function<bool(const Node&)> &f) {
			assert(ll >= 0 && ll <= rr && rr < n);
			return find_last(1, 0, n - 1, ll, rr, f);
		}
	};
	${0}

snippet triestr "Trie on Strings, O(n)"
	struct Trie {
		int sz;
		vector<int> cnt_prefix, cnt_word;
		vector<array<int, 26>> nxt;

		Trie(int n) : sz(1) {
			cnt_prefix.assign(n, 0);
			cnt_word.assign(n, 0);
			nxt.assign(n, array<int, 26>());
		}

		void insert(const string &s) {
			int v = 0;
			for (auto ch : s) {
				int ind = ch - 'a';
				if (!nxt[v][ind]) {
					nxt[v][ind] = sz++;
				}
				v = nxt[v][ind];
				cnt_prefix[v]++;
			}
			cnt_word[v]++;
		}

		void erase(const string &s) {
			int v = 0;
			for (auto ch : s) {
				int ind = ch - 'a';
				v = nxt[v][ind];
				cnt_prefix[v]--;
				assert(cnt_prefix[v] >= 0);
			}
			cnt_word[v]--;
			assert(cnt_word[v] >= 0);
		}

		int count_prefix(const string &s) {
			int v = 0;
			for (auto ch : s) {
				int ind = ch - 'a';
				if (!nxt[v][ind]) {
					return 0;
				}
				v = nxt[v][ind];
			}
			return cnt_prefix[v];
		}

		int count_word(const string &s) {
			int v = 0;
			for (auto ch : s) {
				int ind = ch - 'a';
				if (!nxt[v][ind]) {
					return 0;
				}
				v = nxt[v][ind];
			}
			return cnt_word[v];
		}
	};
	${0}

snippet triebit "Trie on Bits, O(n)"
	template <typename T>
	struct Trie {
		int sz;
		vector<int> cnt_prefix, cnt_word;
		vector<array<int, 2>> nxt;
		const int B = numeric_limits<T>::digits - 1;

		Trie(int n) : sz(1) {
			cnt_prefix.assign(n, 0);
			cnt_word.assign(n, 0);
			nxt.assign(n, array<int, 2>());
		}

		void insert(const T &x) {
			int v = 0;
			for (int i = B; i >= 0; i--) {
				int bit = x >> i & 1;
				if (!nxt[v][bit]) {
					nxt[v][bit] = sz++;
				}
				v = nxt[v][bit];
				cnt_prefix[v]++;
			}
			cnt_word[v]++;
		}

		void erase(const T &x) {
			int v = 0;
			for (int i = B; i >= 0; i--) {
				int bit = x >> i & 1;
				v = nxt[v][bit];
				cnt_prefix[v]--;
				assert(cnt_prefix[v] >= 0);
			}
			cnt_word[v]--;
			assert(cnt_word[v] >= 0);
		}

		int count_prefix(const T &x) {
			int v = 0;
			for (int i = B; i >= 0; i--) {
				int bit = x >> i & 1;
				if (!nxt[v][bit]) {
					return 0;
				}
				v = nxt[v][bit];
			}
			return cnt_prefix[v];
		}

		int count_word(const T &x) {
			int v = 0;
			for (int i = B; i >= 0; i--) {
				int bit = x >> i & 1;
				if (!nxt[v][bit]) {
					return 0;
				}
				v = nxt[v][bit];
			}
			return cnt_word[v];
		}

		T max_xor(const T &x) {
			T res{};
			int v = 0;
			for (int i = B; i >= 0; i--) {
				int bit = x >> i & 1;
				if (cnt_prefix[nxt[v][bit ^ 1]]) {
					v = nxt[v][bit ^ 1];
					res += T(1) << i;
				}
				else {
					v = nxt[v][bit];
				}
			}
			return res;
		}
	};
	${0}

snippet mo "MO's Algorithm, O((n+q)*sqrt(n)*F)"
	const int B = 440;
	struct Query {
		int l, r, id;
		bool operator<(const Query &other) const {
			if (l / B == other.l / B) {
				return ((l / B) & 1) ? r > other.r : r < other.r;
			}
			return l / B < other.l / B;
		}
	};
	${0}

snippet segtree2d "Segment Tree 2D"
	class segtree_2d {
	public:
		struct node {
			int64_t sum = 0;
			int mn = 0;
			int cnt = 1;

			void apply(int v) {
				mn = v;
				sum = v;
			}
		};

		node unite(const node &a, const node &b) const {
			node res;
			res.sum = a.sum + b.sum;
			res.mn = min(a.mn, b.mn);
			res.cnt = (res.mn == a.mn ? a.cnt : 0) + (res.mn == b.mn ? b.cnt : 0);
			return res;
		}

		inline void pull_x(int x, int y) {
			tree[x][y] = unite(tree[x * 2][y], tree[x * 2 + 1][y]);
		}

		inline void pull_y(int x, int y) {
			tree[x][y] = unite(tree[x][y * 2], tree[x][y * 2 + 1]);
		}

		int n, m;
		vector<vector<node>> tree;

		void build_y(int x, int lx, int rx, int y, int ly, int ry) {
			if (ly == ry) {
				if (lx == rx) {
					return;
				}
				else {
					pull_x(x, y);
				}
				return;
			} 
			int my = (ly + ry) / 2;
			build_y(x, lx, rx, y * 2, ly, my);
			build_y(x, lx, rx, y * 2 + 1, my + 1, ry);
			pull_y(x, y);
		}

		void build_x(int x, int lx, int rx) {
			if (lx != rx) {
				int mx = (lx + rx) / 2;
				build_x(x * 2, lx, mx);
				build_x(x * 2 + 1, mx + 1, rx);
			}
			build_y(x, lx, rx, 1, 0, m - 1);
		}

		template <typename M>
		void build_y(int x, int lx, int rx, int y, int ly, int ry, const vector<vector<M>> &v) {
			if (ly == ry) {
				if (lx == rx) {
					tree[x][y].apply(v[lx][ly]);
				}
				else {
					pull_x(x, y);
				}
				return;
			} 
			int my = (ly + ry) / 2;
			build_y(x, lx, rx, y * 2, ly, my, v);
			build_y(x, lx, rx, y * 2 + 1, my + 1, ry, v);
			pull_y(x, y);
		}

		template <typename M>
		void build_x(int x, int lx, int rx, const vector<vector<M>> &v) {
			if (lx != rx) {
				int mx = (lx + rx) / 2;
				build_x(x * 2, lx, mx, v);
				build_x(x * 2 + 1, mx + 1, rx, v);
			}
			build_y(x, lx, rx, 1, 0, m - 1, v);
		}

		void modify_y(int x, int lx, int rx, int y, int ly, int ry, int px, int py, const int v) {
			if (ly == ry) {
				if (lx == rx) {
					tree[x][y].apply(v);
				}
				else {
					pull_x(x, y);
				}
			} 
			else {
				int my = (ly + ry) / 2;
				if (py <= my) {
					modify_y(x, lx, rx, y * 2, ly, my, px, py, v);
				}
				else {
					modify_y(x, lx, rx, y * 2 + 1, my + 1, ry, px, py, v);
				}
				pull_y(x, y);
			}
		}

		void modify_x(int x, int lx, int rx, int px, int py, const int v) {
			if (lx != rx) {
				int mx = (lx + rx) / 2;
				if (px <= mx) {
					modify_x(x * 2, lx, mx, px, py, v);
				}
				else {
					modify_x(x * 2 + 1, mx + 1, rx, px, py, v);
				}
			}
			modify_y(x, lx, rx, 1, 0, m - 1, px, py, v);
		}

		node get_y(int x, int y, int ly, int ry, int lly, int rry) {
			if (lly <= ly && ry <= rry) {
				return tree[x][y];
			}
			int my = (ly + ry) / 2;
			if (my >= rry) {
				return get_y(x, y * 2, ly, my, lly, rry);
			}
			else if (my < lly) {
				return get_y(x, y * 2 + 1, my + 1, ry, lly, rry);
			}
			return unite(get_y(x, y * 2, ly, my, lly, rry), get_y(x, y * 2 + 1, my + 1, ry, lly, rry));
		}

		node get_x(int x, int lx, int rx, int llx, int rrx, int lly, int rry) {
			if (llx <= lx && rx <= rrx) {
				return get_y(x, 1, 0, m - 1, lly, rry);
			}
			int mx = (lx + rx) / 2;
			if (mx >= rrx) {
				return  get_x(x * 2, lx, mx, llx, rrx, lly, rry);
			}
			else if (mx < llx) {
				return get_x(x * 2 + 1, mx + 1, rx, llx, rrx, lly, rry);
			}
			return unite(get_x(x * 2, lx, mx, llx, rrx, lly, rry), get_x(x * 2 + 1, mx + 1, rx, llx, rrx, lly, rry));
		}

		segtree_2d(int _n, int _m) : n(_n), m(_m) {
			assert(n > 0 && m > 0);
			tree.assign(4 * n, vector<node>(4 * m));
			build_x(1, 0, n - 1);
		}

		template <typename M>
		segtree_2d(const vector<M> &v) {
			n = v.size();
			m = v[0].size();
			assert(n > 0 && m > 0);
			tree.assign(4 * n, vector<node>(4 * m));
			build_x(1, 0, n - 1, v);
		}

		node get(int llx, int rrx, int lly, int rry) {
			assert(0 <= llx && llx <= rrx && rrx <= n - 1);
			assert(0 <= lly && lly <= rry && rry <= m - 1);
			return get_x(1, 0, n - 1, llx, rrx, lly, rry);
		}

		node get(int px, int py) {
			assert(0 <= px && px <= n - 1);
			assert(0 <= py && py <= m - 1);
			return get_x(1, 0, n - 1, px, px, py, py);
		}

		void modify(int px, int py, const int v) {
			assert(px >= 0 && px <= n - 1);
			assert(py >= 0 && py <= m - 1);
			modify_x(1, 0, n - 1, px, py, v);
		}
	};
	${0}

snippet ordered_set "Ordered Set & Ordered Map"
	// s.order_of_key(k) -> number of elements less than k 
	// *s.find_by_order(index) -> s[index]
	#include <ext/pb_ds/assoc_container.hpp>
	#include <ext/pb_ds/tree_policy.hpp>
	using namespace __gnu_pbds;
	template <typename T>
	using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
	template <typename T, typename R> 
	using ordered_map = tree<T, R, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
	${0}

snippet treap "Treap, Max Heap" 
	mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

	template <typename T>
	struct Treap {
		struct Node {
			T key;
			int prior, sz, left, right, par;

			Node (T _key) : key(_key), prior(rng()), sz(1), left(-1), right(-1), par(-1) {}
			Node (T _key, int _prior) : key(_key), prior(_prior), sz(1), left(-1), right(-1), par(-1) {}
		};

		int root;
		vector<Node> tree;

		Treap() : root(-1) {}
		Treap(int n) : root(-1) {
			tree.reserve(n);
		}
		// Construction with sorted keys, O(n)
		Treap(vector<T> &keys) {
			int n = keys.size();
			tree.reserve(n);
			root = build(keys, 0, n - 1);
		}
		// Construction with sorted keys & priors, O(n)
		Treap(vector<T> &keys, vector<int> &priors) {
			assert(keys.size() == priors.size());
			int n = keys.size();
			tree.reserve(n);
			root = build(keys, priors);
			pull_size(root);
		}

		int build(vector<T> &keys, int lo, int hi) {
			if (lo > hi) {
				return -1;
			}
			int mid = lo + (hi - lo) / 2;
			int x = new_node(keys[mid]);
			tree[x].left = build(keys, lo, mid - 1);
			tree[x].right = build(keys, mid + 1, hi);
			heapify(x);
			pull(x);
			return x;
		}

		void heapify(int x) {
			if (x == -1) {
				return;
			}
			int mx = x;
			if (tree[x].left != -1 && tree[tree[x].left].prior > tree[mx].prior) {
				mx = tree[x].left;
			}
			if (tree[x].right != -1 && tree[tree[x].right].prior > tree[mx].prior) {
				mx = tree[x].right;
			}
			if (mx != x) {
				swap(tree[x].prior, tree[mx].prior);
				heapify(mx);
			}
		}

		int build(vector<T> &keys, vector<int> &priors) {
			int n = keys.size();
			for (int i = 0; i < n; i++) {
				tree.push_back(Node(keys[i], priors[i]));
			}
			vector<int> st;
			for (int i = 0; i < n; i++) {
				while (!st.empty() && tree[st.back()].prior < tree[i].prior) {
					st.pop_back();
				}
				if (!st.empty() && (tree[i].par == -1 || tree[tree[i].par].prior > tree[st.back()].prior)) {
					tree[i].par = st.back();
				}
				st.push_back(i);
			}
			st.clear();
			for (int i = n - 1; i >= 0; i--) {
				while (!st.empty() && tree[st.back()].prior < tree[i].prior) {
					st.pop_back();
				}
				if (!st.empty() && (tree[i].par == -1 || tree[tree[i].par].prior > tree[st.back()].prior)) {
					tree[i].par = st.back();
				}
				st.push_back(i);
			}
			for (int i = 0; i < n; i++) {
				if (tree[i].par != -1) {
					if (tree[tree[i].par].key < tree[i].key) {
						tree[tree[i].par].right = i;
					} 
					else {
						tree[tree[i].par].left = i;
					}
				}
			}
			return n ? min_element(priors.begin(), priors.end()) - priors.begin() : -1;
		}

		void pull_size(int x) {
			if (x == -1) {
				return;
			}
			if (tree[x].left != -1) {
				pull_size(tree[x].left);
			}
			if (tree[x].right != -1) {
				pull_size(tree[x].right);
			}
			pull(x);
		}

		inline void pull(int x) {
			tree[x].sz = size(tree[x].left) + size(tree[x].right) + 1;
		}

		int size(int x) const {
			return (x == -1 ? 0 : tree[x].sz);
		}

		int new_node(T key, int prior = rng()) {
			int id = int(tree.size());
			tree.push_back(Node(key, prior));
			return id;
		}

		inline void add_right(int x, int right) {
			tree[x].right = right;
			if (right != -1) {
				tree[right].par = x;
			}
		}

		inline void add_left(int x, int left) {
			tree[x].left = left;
			if (left != -1) {
				tree[left].par = x;
			}
		}

		pair<int, int> split_by_key(int x, T key) {
			if (x == -1) {
				return {x, x};
			}
			if (tree[x].key <= key) {
				auto cur = split_by_key(tree[x].right, key);
				add_right(x, cur.first);
				pull(x);
				return {x, cur.second};
			} 
			else {
				auto cur = split_by_key(tree[x].left, key);
				add_left(x, cur.second);
				pull(x);
				return {cur.first, x};
			}
		}

		pair<int, int> split_by_size(int x, int n) {
			if (x == -1) {
				return {x, x};
			}
			if (size(tree[x].left) + 1 <= n) {
				auto cur = split_by_size(tree[x].right, n - size(tree[x].left) - 1);
				add_right(x, cur.first);
				pull(x);
				return {x, cur.second};
			} 
			else {
				auto cur = split_by_size(tree[x].left, n);
				add_left(x, cur.second);
				pull(x);
				return {cur.first, x};
			}
		}

		int merge(int left, int right) {
			if (left == -1 || right == -1) {
				return left != -1 ? left : right;
			}
			if (tree[left].prior > tree[right].prior) {
				add_right(left, merge(tree[left].right, right));
				pull(left);
				return left;
			} 
			else {
				add_left(right, merge(left, tree[right].left));
				pull(right);
				return right;
			}
		}
	 
		int insert(int x, T key, int id) {
			if (x == -1) {
				return id;
			}
			if (tree[id].prior < tree[x].prior) {
				if (key < tree[x].key) {
					add_left(x, insert(tree[x].left, key, id));
				}
				else {
					add_right(x, insert(tree[x].right, key, id));
				}
				pull(x);
				return x;
			} 
			else {
				auto [left, right] = split_by_key(x, key);
				add_left(id, left);
				add_right(id, right);
				pull(id);
				return id;
			}
		}
	 
		int erase(int x, T key) {
			if (x == -1) {
				return -1;
			}
			if (tree[x].key == key) {
				return merge(tree[x].left, tree[x].right);
			}
			if (key < tree[x].key) {
				add_left(x, erase(tree[x].left, key));
			}
			else {
				add_right(x, erase(tree[x].right, key));
			}
			pull(x);
			return x;
		}

		T at(int x, int pos) {
			if (size(tree[x].left) > pos) {
				return at(tree[x].left, pos);
			}
			pos -= size(tree[x].left);
			if (!pos) {
				return tree[x].key;
			}
			return at(tree[x].right, pos - 1);
		}

		int find(int x, T key) {
			if (x == -1) {
				return 0;
			}
			if (tree[x].key >= key) {
				return find(tree[x].left, key);
			}
			else {
				return size(tree[x].left) + 1 + find(tree[x].right, key);
			}
		}

		bool contains(int x, T key) {
			if (x == -1) {
				return false;
			}
			if (tree[x].key == key) {
				return true;
			}
			if (tree[x].key < key) {
				return contains(tree[x].right, key);
			}
			return contains(tree[x].left, key);
		}

		int unite(int l, int r) {
			if (l == -1 || r == -1)  {
				return l != -1 ? l : r;
			}
			if (tree[l].prior < tree[r].prior)  {
				swap(l, r);
			}
			auto [lt, rt] = split_by_key(r, tree[l].key);
			add_left(l, unite(tree[l].left, lt));
			add_right(l, unite(tree[l].right, rt));
			return l;
		}
	 
		void insert(T key) {
			int id = new_node(key);
			root = insert(root, key, id);
		}

		void insert(T key, int prior) {
			int id = new_node(key, prior);
			root = insert(root, key, id);
		}
	 
		void erase(T key) {
			root = erase(root, key);
		}
	 
		int size() const {
			return size(root);
		}

		T at(int pos) {
			assert(pos >= 0 && pos < size());
			return at(root, pos);
		}

		// Return number of elements smaller than key
		int find(T key) {
			return find(root, key);
		}

		bool contains(T key) {
			return contains(root, key);
		}

		// Unite 2 Treaps, O(m*log(n / m))
		void unite(Treap<T> &t) {
			int n = size();
			for (int i = 0; i < t.size(); i++) {
				tree.push_back(t.tree[i]);
			}
			root = unite(root, n);
		}
	};
	${0}

snippet dfs "Depth First Search, O(n + m)" 
    vector<bool> vis(n);
    vector<int> in(n), out(n), order;
    order.reserve(n);
    int timer = 0;
    auto dfs = [&](auto &&self, int v) -> void {
        vis[v] = true;
        in[v] = timer++;
        order.push_back(v);
        for (auto u : adj[v]) {
            if (!vis[u]) {
                self(self, u);
            }
        }
        out[v] = timer;
    };

snippet bfs "Breadth First Search, O(n + m)" 
    constexpr int INF = 1e9;
    vector<int> dist(n, INF), par(n, -1);
    auto bfs = [&](int s) -> void {
        queue<int> q;
        q.push(s);
        dist[s] = 0;
        while (!q.empty()) {
            int v = q.front();
            q.pop();

            for (auto u : adj[v]) {
                if (dist[v] + 1 < dist[u]) {
                    q.push(u);
                    dist[u] = dist[v] + 1;
                    par[u] = v;
                }
            }
        }
    };

snippet topsort "Topological Sorting, O(n + m)"
    // An order of vertices in DAG that every edge leads from 
    // the vertex with a smaller index to a vertex with a larger one.
    vector<bool> vis(n);
    vector<int> order;
    order.reserve(n);
    auto dfs = [&](auto &&self, int v) -> void {
        vis[v] = true;
        for (auto u : adj[v]) {
            if (!vis[u]) {
                self(self, u);
            }
        }
        order.push_back(v);
    };
    auto topological_sorting = [&]() -> void {
        for (int v = 0; v < n; v++) {
            if (!vis[v]) {
                dfs(dfs, v);
            }
        }
        reverse(order.begin(), order.end());
    };

snippet bipartite "Check an Undirected Graph is Bipartite, O(n + m)"
    vector<int> color(n, -1);
    vector<vector<int>> c(2);
    auto is_bipartite = [&]() -> bool {
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (color[i] == -1) {
                color[i] = 0;
                c[color[i]].push_back(i);
                q.push(i); 
                while (!q.empty()) {
                    int v = q.front();
                    q.pop();

                    for (auto u : adj[v]) {
                        if (color[u] == -1) {
                            color[u] = color[v] ^ 1;
                            c[color[u]].push_back(u);
                            q.push(u);
                        }
                        else if (color[u] == color[v]) {
                            return false;
                        }
                    }
                }

            }
        }
        return true;
    };

snippet ucycle "Find Cycle in Undirected Graph, O(n + m)" 
    vector<bool> vis(n);
    vector<int> par(n, -1), cycle;
    int cycle_start, cycle_end;
    auto dfs = [&](auto &&self, int v, int p) -> bool {
        vis[v] = true;
        for (auto u : adj[v]) {
            if (u == p) {
                continue; 
            }
            if (vis[u]) {
                cycle_end = v;
                cycle_start = u;
                return true;
            }
            par[u] = v;
            if (self(self, u, v)) {
                return true;
            }
        }
        return false;
    };
    auto find_cycle = [&]() -> bool {
        cycle.clear();
        cycle_start = -1;
        for (int v = 0; v < n; v++) {
            if (!vis[v] && dfs(dfs, v, -1)) {
                break;
            }
        }
        if (cycle_start == -1) {
            return false;
        } 

        for (int v = cycle_end; v != cycle_start; v = par[v]) {
            cycle.push_back(v);
        }
        cycle.push_back(cycle_start);
        return true;
    };

snippet dcycle "Find Cycle in Directed Graph, O(n + m)" 
    vector<int> color(n), par(n, -1), cycle;
    int cycle_start, cycle_end;
    auto dfs = [&](auto &&self, int v) -> bool {
        color[v] = 1;
        for (auto u : adj[v]) {
            if (color[u] == 0) {
                par[u] = v;
                if (self(self, u)) {
                    return true;
                }
            } 
            else if (color[u] == 1) {
                cycle_end = v;
                cycle_start = u;
                return true;
            }
        }
        color[v] = 2;
        return false;
    };
    auto find_cycle = [&]() -> bool {
        cycle.clear();
        cycle_start = -1;
        for (int v = 0; v < n; v++) { 
            if (color[v] == 0 && dfs(dfs, v)) {
                break;
            }
        }
        if (cycle_start == -1) {
            return false;
        }

        for (int v = cycle_end; v != cycle_start; v = par[v]) {
            cycle.push_back(v);
        }
        cycle.push_back(cycle_start);
        reverse(cycle.begin(), cycle.end());
        return true;
    };

snippet bridges "Find Articulation Bridges in Undirected Graph, O(n + m)" 
    vector<bool> vis(n);
    vector<int> tin(n), low(n);
    vector<pair<int, int>> bridges;
    int timer = 0;
    auto dfs = [&](auto &&self, int v, int p) -> void {
        vis[v] = true;
        tin[v] = low[v] = timer++;
        for (auto u : adj[v]) {
            if (u == p) {
                continue;
            }
            if (vis[u]) {
                low[v] = min(low[v], tin[u]);
            } 
            else {
                self(self, u, v);
                low[v] = min(low[v], low[u]);
                if (low[u] > tin[v]) {
                    bridges.emplace_back(v, u);
                }
            }
        }
    };
    auto find_bridges = [&]() -> void {
        for (int v = 0; v < n; v++) {
            if (!vis[v]) {
                dfs(dfs, v, -1);
            }
        }
    };

snippet artpoints "Find Articulation Points in Undirected Graph, O(n + m)" 
    vector<bool> vis(n);
    vector<int> tin(n), low(n), art_points;
    int timer = 0;
    auto dfs = [&](auto &&self, int v, int p) -> void {
        vis[v] = true;
        tin[v] = low[v] = timer++;
        int children = 0;
        for (auto u : adj[v]) {
            if (u == p) {
                continue;
            }
            if (vis[u]) {
                low[v] = min(low[v], tin[u]);
            } 
            else {
                self(self, u, v);
                low[v] = min(low[v], low[u]);
                if (low[u] >= tin[v] && p != -1) {
                    art_points.push_back(v);
                }
                children++;
            }
        }
        if (p == -1 && children > 1) {
            art_points.push_back(v);
        }
    };
    auto find_art_points = [&]() {
        for (int v = 0; v < n; v++) {
            if (!vis[v]) {
                dfs(dfs, v, -1);
            }
        }
        // Some points may be added several times
        sort(art_points.begin(), art_points.end());
        art_points.erase(unique(art_points.begin(), art_points.end()), art_points.end());
    };

snippet bridgetree "Bridge Tree for Undirected Graph, O(n + m)"
	struct Bridge_Tree {
		int n, sz, timer;
		vector<vector<int>> adj, g;
		vector<bool> vis;
		vector<int> tin, low, comp;
		vector<pair<int, int>> bridges;

		void dfs(int v, int p) {
			vis[v] = true;
			tin[v] = low[v] = timer++;
			for (auto u : adj[v]) {
				if (u == p) {
					continue;
				}
				if (vis[u]) {
					low[v] = min(low[v], tin[u]);
				} 
				else {
					dfs(u, v);
					low[v] = min(low[v], low[u]);
				}
			}
		};

		void dfs2(int v, int c) {
			comp[v] = c;
			for (auto u : adj[v]) {
				if (comp[u] != -1) {
					continue;
				}
				if (low[u] > tin[v]) {
					bridges.emplace_back(v, u);
					dfs2(u, ++sz);
				} 
				else {
					dfs2(u, c);
				}
			}
		}

		Bridge_Tree(const vector<vector<int>> &_adj) : n(_adj.size()), adj(_adj) {
			vis.resize(n);
			tin.resize(n); 
			low.resize(n);
			comp.resize(n, - 1);
			sz = timer = 0;

			for (int v = 0; v < n; v++) {
				if (!vis[v]) {
					dfs(v, -1);
					dfs2(v, sz);
					sz++;
				}
			}
			g.resize(sz);
			for (auto [u, v] : bridges) {
				u = comp[u], v = comp[v];
				g[u].push_back(v);
				g[v].push_back(u);
			}
		}
	};
	${0}

snippet scc "Strong Connected Components" 
	vector<int> order, component, root_nodes, roots(N), adj_scc[N];

	void dfs1(int u) {
		vis[u] = true;

		for (auto &v : adj[u]) {
			if (!vis[v]) {
				dfs1(v);
			}
		}
		order.push_back(u);
	}

	void dfs2(int u) {
		vis[u] = true;
		component.push_back(u);

		for (auto &v : adj_rev[u]) { 
			if (!vis[v]) {
				dfs2(v);
			}
		}
	}

	void scc(int n) {
		order.clear();
		root_nodes.clear();

		for (int u = 0; u < n; u++) {
			if (!vis[u]) {
				dfs1(u);
			}
		}
		reverse(order.begin(), order.end());

		fill(vis, vis + n, false);
		for (auto &u : order) {
			if (!vis[u]) {
				dfs2(u);
				int root = component.front();
				for (auto &v : component) {
					roots[v] = root;
				}
				root_nodes.push_back(root);

				adj_scc[root].clear();
				component.clear();
			}
		}
		
		for (int u = 0; u < n; u++) {
			for (auto &v : adj[u]) {
				int root_u = roots[u], root_v = roots[v];
				if (root_u != root_v) {
					adj_scc[root_u].push_back(root_v);
				}
			}
		}
	}
	${0}

snippet centroids "Find Centroids of a tree, O(n + m)" 
    // A node such that when the tree is rooted at it, no other nodes have a subtree of size greater than n/2
    vector<int> sz(n), centroids;
    auto dfs = [&](auto &&self, int v, int p) -> void {
        sz[v] = 1;
        for (auto u : adj[v]) {
            if (u == p) {
                continue;
            }
            self(self, u, v);
            sz[v] += sz[u];
        }
    };
    auto find_centroids = [&]() -> void {
        int v = 0;
        dfs(dfs, v, -1);
        while (true) {
            int tmp = -1;
            for (auto u : adj[v]) {
                if (sz[u] > sz[v]) {
                    continue;
                }
                if (2 * sz[u] >= n) {
                    tmp = u;
                }
            }
            if (tmp == -1) {
                break;
            }
            v = tmp;
        }
        dfs(dfs, v, -1);
        for (auto u : adj[v]) {
            if (2 * sz[u] == n) {
                centroids.push_back(u);
                centroids.push_back(v);
                return;
            }
        }
        centroids.push_back(v);
    };

snippet euler_tour "Euler Tour Technique (ETT)" 
    // add x to node v and get sum subtree v: add(v, x) -> add(in[v], x), sum(v) -> sum(in[v], out[v])
    // add x to node v and get sum path v to root=0: add(v, x) -> add(in[v], x) add(out[v], -x), sum(v) -> sum(0, in[v])
    vector<int> in(n), out(n);
    int timer = 0;
    auto dfs = [&](auto &&self, int v, int p) -> void {
        in[v] = timer++;
        for (auto u : adj[v]) {
            if (u == p) {
                continue;
            }
            self(self, u, v);
        }
        out[v] = timer;
    };
    dfs(dfs, 0, -1);
	
snippet floyd "Find All Shortest Path, O(n^3)" 
    // Graph may have negative weight but no have negative weight cycle
    // if graph have negative weight cycle, exist a vertex v such that dist[v][v] < 0
    constexpr int64_t INF = 1e18;
    vector dist(n, vector<int64_t>(n, INF));
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--, v--;
        dist[u][v] = min<int64_t>(dist[u][v], w);
        dist[v][u] = min<int64_t>(dist[v][u], w);
    }
    for (int i = 0; i < n; i++) {
        dist[i][i] = 0;
    }

    auto floyd_warshall = [&]() -> void {
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] < INF && dist[k][j] < INF) {
                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }
    };

snippet dijkstra "Single Source Shortest Path, O(m*log(n))"
    constexpr int64_t INF = 1e18;
    vector<int64_t> dist(n, INF), cnt(n, 0);
    vector<int> par(n, -1);
    auto dijkstra = [&](int s) -> void {
        priority_queue<pair<int64_t, int>, vector<pair<int64_t, int>>, greater<pair<int64_t, int>>> pq;
        dist[s] = 0;
        cnt[s] = 1;
        pq.emplace(dist[s], s);
        while (!pq.empty()) {
            auto [dist_v, v] = pq.top();
            pq.pop();

            if (dist_v != dist[v]) {
                continue;
            }
            for (auto [u, w] : adj[v]) {
                if (dist[v] + w < dist[u]) {
                    dist[u] = dist[v] + w;
                    cnt[u] = cnt[v];
                    par[u] = v;
                    pq.emplace(dist[u], u);
                }
                else if (dist[v] + w == dist[u]) {
                    cnt[u] = (cnt[u] + cnt[v]); // MOD
                }
            }
        }
    };

snippet bellman "Bellman Ford" 
	struct Edge {
		int64_t u, v, w;
	}; 

	const int64_t INF = 4e18;
	vector<Edge> edges;
	vector<int> neg_path;
	int64_t d[N], p[N];

	// false -> exist negative cycle 
	bool bellman_ford(int s, int n) { // O(n*m)  
		fill(d, d + n, INF);
		fill(p, p + n, -1);
		neg_path.clear();

		d[s] = 0;
		int x = -1;
		for (int i = 0; i < n; i++) {
			x = -1;
			for (auto &e : edges) {
				if (d[e.u] < INF) {
					if (d[e.v] > d[e.u] + e.w) {
						d[e.v] = max(-INF, d[e.u] + e.w);
						p[e.v] = e.u;
						x = e.v;
					}
				}
			}
			if (x == -1) {
				return false;
			}
		}

		int y = x;
		for (int i = 0; i < n; i++) {
			y = p[y];
		}
		for (int cur = y; ; cur = p[cur]) {
			neg_path.push_back(cur);
			if (cur == y && int(neg_path.size()) > 1) {
				break;
			}
		}
		reverse(neg_path.begin(), neg_path.end());

		return true;
	}
	${0}

snippet spfa "SPFA (Shortest Path Fast Algorithm)" 
	const int64_t INF = 4e18;
	int64_t d[N], cnt[N];
	bool inq[N];

	// false -> exist negative cycle
	bool spfa(int s, int n) { // O(n*m)
		fill(d, d + n, INF);
		fill(cnt, cnt + n, 0);
		fill(inq, inq + n, 0);

		queue<int> q;
		q.push(s);
		d[s] = 0;
		inq[s] = true;
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			inq[u] = false;

			for (auto &e : adj[u]) {
				auto [v, w] = e.first;

				if (d[u] + w < d[v]) {
					d[v] = d[u] + w;
					if (!inq[v]) {
						q.push(v);
						inq[v] = true;
						cnt[v]++;
						if (cnt[v] > n) {
							return false; 
						}
					}
				}
			}
		}
		return true;
	}
	${0}

snippet prim "Prim MST" 
	const int INF = 1e9;
	struct Edge {
		int w = INF;
		int to = -1;
	};

	bool used[N];
	Edge mst[N];

	// complete graph, -1 -> not exist mst
	int64_t prim(int n) { // O(n^2)
		fill(used, used + n, 0);

		int64_t total_weight = 0;
		mst[0].w = 0;
		for (int i = 0; i < n; i++) {
			int u = -1;
			for (int j = 0; j < n; j++) {
				if (!used[j] && (u == -1 || mst[j].w < mst[u].w)) {
					u = j;
				}
			}
			if (mst[u].w == INF) {
				return -1;
			}

			used[u] = true;
			total_weight += mst[u].w;
			for (int v = 0; v < n; v++) {
				if (adj[u][v] < mst[v].w) {
					mst[v].to = u; 
					mst[v].w = adj[u][v];
				}
			}
		}
		
		return total_weight;
	}
	${0}

snippet kruskal "Kruskal MST" 
	struct Edge {
		int u, v, w;
		bool operator < (Edge const &other) {
			return w < other.w;
		}
	} edges[N]; 
	vector<Edge> result;

	struct dsu {
		vector<int> parent, sz;

		dsu(int n) {
			parent.resize(n); sz.resize(n);;
			for (int i = 0; i < n; i++) {
				make(i);
			}
		}

		void make(int a) {
			parent[a] = a;
			sz[a] = 1;
		}
		int find(int a) {
			return (parent[a] == a ? a : (parent[a] = find(parent[a])));
		}
		bool same(int a, int b) {
			return find(a) == find(b);
		}
		void merge(int a, int b) {
			if ((a = find(a)) != (b = find(b))) {
				if (sz[a] > sz[b]) {
					swap(a, b);
				}
				parent[a] = b;
				sz[b] += sz[a];
			}
		}
	};

	// -1 -> not exitst mst
	int64_t kruskal(int n, int m) { // O(m*log(n))
		result.clear();
		int64_t total_weight = 0;
		sort(edges, edges + m);

		dsu d(n);
		
		int nodes = 0;
		for (auto &e : edges) {
			if (!d.same(e.u, e.v)) {
				total_weight += e.w;
				result.push_back(e);
				d.merge(e.u, e.v);
				nodes++;
			}
			if (nodes == n - 1) {
				break;
			}
		}

		if (nodes != n - 1) {
			return -1;
		}
		return total_weight;
	}
	${0}

snippet towsat "2-SAT (Boolean satisfiability problem)"
	struct TwoSat {
		int n;
		vector<vector<int>> e;
		vector<bool> ans;

		TwoSat(int n) : n(n), e(2 * n), ans(n) {}

		void add_clause(int u, bool f, int v, bool g) {
			e[2 * u + !f].push_back(2 * v + g);
			e[2 * v + !g].push_back(2 * u + f);
		}
		bool satisfiable() {
			vector<int> id(2 * n, -1), dfn(2 * n, -1), low(2 * n, -1);
			vector<int> stk;
			int now = 0, cnt = 0;
			function<void(int)> tarjan = [&](int u) {
				stk.push_back(u);
				dfn[u] = low[u] = now++;
				for (auto v : e[u]) {
					if (dfn[v] == -1) {
						tarjan(v);
						low[u] = min(low[u], low[v]);
					} 
					else if (id[v] == -1) {
						low[u] = min(low[u], dfn[v]);
					}
				}
				if (dfn[u] == low[u]) {
					int v;
					do {
						v = stk.back();
						stk.pop_back();
						id[v] = cnt;
					} while (v != u);
					cnt++;
				}
			};
			for (int i = 0; i < 2 * n; i++) {
				if (dfn[i] == -1) {
					tarjan(i);
				}
			}
			for (int i = 0; i < n; i++) {
				if (id[2 * i] == id[2 * i + 1]) {
					return false;
				}
				ans[i] = id[2 * i] > id[2 * i + 1];
			}
			return true;
		}
		vector<bool> answer() { 
			return ans;
		}
	};
	${0}

snippet flow1 "Maximum Flow (Edmons-Karp), O(n * m^2)"
	// Maximum Flow (Edmons-Karp), O(n * m^2)
	template <typename T>
	struct Flow {
		struct Edge {
			int from, to;
			T cap, flow;
			Edge(int _from, int _to, T _cap, T _flow) : from(_from), to(_to), cap(_cap), flow(_flow) {}
		};

		const int n;
		vector<vector<int>> adj;
		vector<Edge> edges;
		vector<int> par;

		Flow(int _n) : n(_n), adj(_n) {}

		void add_edge(int u, int v, T c) {
			adj[u].push_back(edges.size());
			edges.emplace_back(u, v, c, 0);
			adj[v].push_back(edges.size());
			edges.emplace_back(v, u, 0, 0);
		}

		bool bfs(int s, int t) {
			par.assign(n, -1);
			queue<int> q;
			par[s] = -2;
			q.push(s);
			while (!q.empty()) {
				int v = q.front();
				q.pop();
				for (int i : adj[v]) {
					auto [_, u, c, f] = edges[i];
					if (c - f > 0 && par[u] == -1) {
						par[u] = i;
						q.push(u);
						if (u == t) {
							return true;
						}
					}
				}
			}
			return false;
		}

		T augment(int s, int t) {
			T flow = numeric_limits<T>::max();
			for (int cur = t; cur != s;) {
				auto [v, _, c, f] = edges[par[cur]];
				flow = min(flow, c - f);
				cur = v;
			}
			for (int cur = t; cur != s;) {
				auto [v, _, c, f] = edges[par[cur]];
				edges[par[cur]].flow += flow;
				edges[par[cur] ^ 1].flow -= flow;
				cur = v;
			}
			return flow;
		}

		T max_flow(int s, int t) {
			T flow = 0;
			while (bfs(s, t)) {
				flow += augment(s, t);
			}
			return flow;
		}
	};
	${0}

snippet split "Split String, O(n)" 
	vector<string> split(const string &s, const char ch = ' ') {
		int n = s.size();
		vector<string> sp;

		string tmp;
		for (int i = 0; i < n; i++) {
			if (s[i] != ch) {
				tmp += s[i];
			}
			else if (tmp != "") {
				sp.push_back(tmp);
				tmp = "";
			}
		}
		if (tmp != "") {
			sp.push_back(tmp);
		}
		return sp;
	}
	${0}

snippet flow2 "Maximum Flow (Dinics), O(n^2 * m)"
	// Maximum Flow (Dinics), O(n^2 * m)
	template <typename T>
	struct Flow {
		struct Edge {
			int from, to;
			T cap, flow;
			Edge(int _from, int _to, T _cap, T _flow) : from(_from), to(_to), cap(_cap), flow(_flow) {}
		};

		const int n;
		vector<vector<int>> adj;
		vector<Edge> edges;
		vector<int> h, cur;

		Flow(int _n) : n(_n), adj(_n) {}

		void add_edge(int u, int v, T c) {
			adj[u].push_back(edges.size());
			edges.emplace_back(u, v, c, 0);
			adj[v].push_back(edges.size());
			edges.emplace_back(v, u, 0, 0);
		}
		
		bool bfs(int s, int t) {
			h.assign(n, -1);
			queue<int> q;
			h[s] = 0;
			q.push(s);
			while (!q.empty()) {
				int v = q.front();
				q.pop();
				for (int i : adj[v]) {
					auto [_, u, c, f] = edges[i];
					if (c - f > 0 && h[u] == -1) {
						h[u] = h[v] + 1;
						q.push(u);
						if (u == t) {
							return true;
						}
					}
				}
			}
			return false;
		}
		
		T dfs(int v, int t, T flow) {
			if (v == t) {
				return flow;
			}
			T r = flow;
			for (int &i = cur[v]; i < int(adj[v].size()); i++) {
				const int j = adj[v][i];
				auto [_, u, c, f] = edges[j];
				if (c - f > 0 && h[u] == h[v] + 1) {
					T a = dfs(u, t, min(r, c - f));
					edges[j].flow += a;
					edges[j ^ 1].flow -= a;
					r -= a;
					if (r == 0) {
						return flow;
					}
				}
			}
			return flow - r;
		}

		T max_flow(int s, int t) {
			T flow = 0;
			while (bfs(s, t)) {
				cur.assign(n, 0);
				flow += dfs(s, t, numeric_limits<T>::max());
			}
			return flow;
		}
	};
	${0}

snippet strip "Strip String, O(n)"
	string strip(const string &s, const char ch = ' ') {
		int n = s.size();
		while (n > 0 && s[n - 1] == ch) {
			n--;
		}

		string res = "";
		for (int i = 0; i < n; i++) {
			if (s[i] == ch) {
				continue;
			}
			while (i < n) {
				res += s[i];
				i++;
			}
		}
		return res;
	}
	${0}

snippet hash "String Hashing, O(1)"
	struct Hash {
		static const uint64_t md = (1LL << 61) - 1;
		static uint64_t step;
		static vector<uint64_t> pw;

		uint64_t addmod(uint64_t a, uint64_t b) const {
			a += b;
			if (a >= md) {
				a -= md;
			}
			return a;
		}

		uint64_t submod(uint64_t a, uint64_t b) const {
			a += md - b;
			if (a >= md) {
				a -= md;
			}
			return a;
		}

		uint64_t mulmod(uint64_t a, uint64_t b) const {
			uint64_t l1 = (uint32_t)a, h1 = a >> 32, l2 = (uint32_t)b, h2 = b >> 32;
			uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;
			uint64_t ret = (l & md) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;
			ret = (ret & md) + (ret >> 61);
			ret = (ret & md) + (ret >> 61);
			return ret - 1;
		}

		void ensure_pw(int sz) {
			int cur = pw.size();
			if (cur < sz) {
				pw.resize(sz);
				for (int i = cur; i < sz; i++) {
					pw[i] = mulmod(pw[i - 1], step);
				}
			}
		}

		int n;
		vector<uint64_t> pref;

		template<typename T>
		Hash(const T &s) {
			n = s.size();
			ensure_pw(n + 1);
			pref.resize(n + 1);
			pref[0] = 1;
			for (int i = 0; i < n; i++) {
				pref[i + 1] = addmod(mulmod(pref[i], step), s[i]);
			}
		}

		inline uint64_t operator()(const int l, const int r) const {
			assert(l >= 0 && l <= r && r < n);
			return submod(pref[r + 1], mulmod(pref[l], pw[r - l + 1]));
		}
	};

	mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

	uint64_t Hash::step = (md >> 2) + rng() % (md >> 1);
	vector<uint64_t> Hash::pw = vector<uint64_t>(1, 1);
	${0}

snippet zfunction "Longest prefix start at index i that match with string s, O(n)"
	vector<int> z_function(const string &s) {
		int n = s.size();
		vector<int> z(n);
		int l = 0, r = 0;
		for (int i = 1; i < n; i++) {
			if (i < r) {
				z[i] = min(r - i, z[i - l]);
			}
			while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
				z[i]++;
			}
			if (i + z[i] > r) {
				l = i;
				r = i + z[i];
			}
		}
		return z;
	}
	${0}

snippet manacher "Find all sub-palindrome, O(n)" 
	// m_even[i] = (m[2i] - 1) / 2, m_odd[i] = m[2i + 1] / 2
	vector<int> manacher(const string &s) {
		string t = "#";
		for (auto c : s) {
			t += c;
			t += '#';
		}

		int n = t.size();
		vector<int> m(n);
		for (int i = 0, j = 0; i < n; i++) {
			if (2 * j - i >= 0 && j + m[j] > i) {
				m[i] = min(m[2 * j - i], j + m[j] - i);
			}
			while (i - m[i] >= 0 && i + m[i] < n && t[i - m[i]] == t[i + m[i]]) {
				m[i]++;
			}
			if (i + m[i] > j + m[j]) {
				j = i;
			}
		}
		return m;
	}
	${0}

snippet suffix_array "Suffix Array, build -> O(n*log(n)), lcp -> O(n)"
	// with global array is faster (2s vs 3s for n = 1e7)
	// constexpr int n = 1e7, lg = 25; int t[n][lg];
	template <typename T, typename Cmp = less<T>>
	struct SparseTable {
		int n;
		vector<vector<T>> t;
		const Cmp cmp = Cmp();

		SparseTable() {}
		SparseTable(const vector<T> &v) {
			build(v);
		}

		inline T f(const T &a, const T &b) const {
			return min(a, b, cmp);
		}
		void build(const vector<T> &v) {
			n = v.size();
			const int lg = __lg(n) + 2;
			t.assign(n, vector<T>(lg));

			for (int i = 0; i < n; i++) {
				t[i][0] = v[i];
			}
			for (int k = 1; k < lg; k++) {
				for (int i = 0; i + (1 << k) - 1 < n; i++) {
					t[i][k] = f(t[i][k - 1], t[i + (1 << (k - 1))][k - 1]);
				}
			}
		}
		T get(int l, int r) { 
			assert(l >= 0 && l <= r && r < n);
			int k = __lg(r - l + 1);
			return f(t[l][k], t[r - (1 << k) + 1][k]);
		}
	};

	// Suffix Array, build -> O(n*log(n)), lcp -> O(n)
	// Numbrer of differents substrings = (n^2 + n) / 2 - sum(lcp)
	struct SuffixArray {
		int n;
		string s;
		vector<int> sa, lcp, rnk;
		SparseTable<int> t;

		SuffixArray(const string &_s, const int char_bound = 256) {
			n = _s.size();
			s = _s;
			suffix_array(s + '$', char_bound);
			build_lcp(s, sa);
			t.build(lcp);
		}

		void suffix_array(const string &s, const int char_bound) {
			int n = s.size();
			sa.resize(n);

			if (char_bound != -1) {
				vector<int> aux(char_bound, 0);
				for (int i = 0; i < n; i++) {
					aux[s[i]]++;
				}
				int sum = 0;
				for (int i = 0; i < char_bound; i++) {
					int add = aux[i];
					aux[i] = sum;
					sum += add;
				}
				for (int i = 0; i < n; i++) {
					sa[aux[s[i]]++] = i;
				}
			} 
			else {
				iota(sa.begin(), sa.end(), 0);
				sort(sa.begin(), sa.end(), [&s](int i, int j) { 
					return s[i] < s[j]; 
				});
			}

			vector<int> sorted_by_second(n);
			vector<int> ptr_group(n);
			vector<int> new_group(n);
			vector<int> group(n);
			group[sa[0]] = 0;
			for (int i = 1; i < n; i++) {
				group[sa[i]] = group[sa[i - 1]] + (!(s[sa[i]] == s[sa[i - 1]]));
			}
			int cnt = group[sa[n - 1]] + 1;
			int step = 1;
			while (cnt < n) {
				int at = 0;
				for (int i = n - step; i < n; i++) {
					sorted_by_second[at++] = i;
				}
				for (int i = 0; i < n; i++) {
					if (sa[i] - step >= 0) {
						sorted_by_second[at++] = sa[i] - step;
					}
				}
				for (int i = n - 1; i >= 0; i--) {
					ptr_group[group[sa[i]]] = i;
				}
				for (int i = 0; i < n; i++) {
					int x = sorted_by_second[i];
					sa[ptr_group[group[x]]++] = x;
				}
				new_group[sa[0]] = 0;
				for (int i = 1; i < n; i++) {
					if (group[sa[i]] != group[sa[i - 1]]) {
						new_group[sa[i]] = new_group[sa[i - 1]] + 1;
					} 
					else {
						int pre = (sa[i - 1] + step >= n ? -1 : group[sa[i - 1] + step]);
						int cur = (sa[i] + step >= n ? -1 : group[sa[i] + step]);
						new_group[sa[i]] = new_group[sa[i - 1]] + (pre != cur);
					}
				}
				swap(group, new_group);
				cnt = group[sa[n - 1]] + 1;
				step <<= 1;
			}
			sa.erase(sa.begin());
		}

		void build_lcp(const string &s, const vector<int> &sa) {
			int n = s.size();
			assert((int)sa.size() == n);
			lcp.resize(max(n - 1, 0));
			rnk.resize(n);

			for (int i = 0; i < n; i++) {
				rnk[sa[i]] = i;
			}
			int k = 0;
			for (int i = 0; i < n; i++) {
				k = max(k - 1, 0);
				if (rnk[i] == n - 1) {
					k = 0;
				} 
				else {
					int j = sa[rnk[i] + 1];
					while (i + k < n && j + k < n && s[i + k] == s[j + k]) {
						k++;
					}
					lcp[rnk[i]] = k;
				}
			}
		}   

		// O(|t|*log(n))
		int lower_bound(const string &t) {
			int l = 0, h = n - 1, ind = n;
			while (l <= h) {
				int mid = (l + h) >> 1;
				bool ok = true;
				for (int i = 0; i < (int)t.size(); i++) {
					if (sa[mid] + i >= n) {
						ok = false;
						break;
					}
					if (s[sa[mid] + i] != t[i]) {
						if (s[sa[mid] + i] < t[i]) {
							ok = false;
						}
						break;
					}
				}
				if (ok) {
					ind = mid;
					h = mid - 1;
				}
				else {
					l = mid + 1;
				}
			}
			return ind;
		}

		int upper_bound(const string &t) {
			int l = 0, h = n - 1, ind = n;
			while (l <= h) {
				int mid = (l + h) >> 1;
				bool ok = false;
				for (int i = 0; i < (int)t.size(); i++) {
					if (sa[mid] + i >= n) {
						break;
					}
					if (s[sa[mid] + i] != t[i]) {
						if (s[sa[mid] + i] > t[i]) {
							ok = true;
						}
						break;
					}
				}
				if (ok) {
					ind = mid;
					h = mid - 1;
				}
				else {
					l = mid + 1;
				}
			}
			return ind;
		}

		// Occurrences of s[p, ..., p + len - 1], O(log(n))
		pair<int, int> find_occurrence(int p, int len) {
			p = rnk[p];
			pair<int, int> ans = {p, p};
			int l = 0, r = p - 1;
			while (l <= r) {
				int mid = (l + r) >> 1;
				if (t.get(mid, p - 1) >= len) {
					ans.first = mid; 
					r = mid - 1;
				}
				else {
					l = mid + 1;
				}
			}
			l = p + 1, r = n - 1;
			while (l <= r) {
				int mid = (l + r) >> 1;
				if (t.get(p, mid - 1) >= len) {
					ans.second = mid; 
					l = mid + 1;
				}
				else {
					r = mid - 1;
				}
			}
			return ans;
		}
	};
	${0}

snippet exgcd "Extended Euclidean Algorithm, O(log(min(a, b)))"
	// g = gcd(a, b) = ax + by
	int64_t exgcd(int64_t a, int64_t b, int64_t &x, int64_t &y) {
		if (b == 0) {
			x = 1;
			y = 0;
			return a;
		}
		int64_t x1, y1;
		int64_t d = exgcd(b, a % b, x1, y1);
		x = y1;
		y = x1 - y1 * (a / b);
		return d;
	}

	int64_t inverse(int64_t a, int64_t mod) {
		int64_t x, y;
		int64_t g = exgcd(a, mod, x, y);
		if (g != 1) {
			return -1;
		}
		return (x % mod + mod) % mod;
	}
	${0}

snippet sieve "Sieve of Eratosthenes, O(n*log(log(n)))"
	vector<bool> is_prime;
	void sieve(int n) {
		is_prime.assign(n + 1, true); 
		is_prime[0] = is_prime[1] = false;

		for (int i = 4; i <= n; i += 2) {
			is_prime[i] = false;
		}
		for (int i = 3; i * i <= n; i += 2) {
			if (is_prime[i]) {
				for (int j = i * i; j <= n; j += 2 * i) {
					is_prime[j] = false;
				}
			}
		}
	}
	${0}

snippet linear_sieve "Linear Sieve with Smallest Prime Factor(SPF), O(n)"
	vector<int> spf, primes;
	void sieve(int n) {
		spf.assign(n + 1, 0);

		for (int i = 2; i <= n; i++) {
			if (spf[i] == 0) {
				spf[i] = i;
				primes.push_back(i);
			}
			for (int j = 0; j < (int)primes.size() && i * primes[j] <= n && primes[j] <= spf[i]; j++) {
				spf[i * primes[j]] = primes[j];
			}
		}
	}
	${0}

snippet mint "Struct Modular Number, MOD Must be Prime" 
	template <typename M>
	struct Modular {
	public:
		using Type = typename decay<decltype(M::value)>::type;

		constexpr Modular() : value() {}
		template <typename T>
		Modular(const T &x) {
			value = normalize(x);
		}

		const Type operator()() const { return value; }
		template <typename T>
		explicit operator T() const { return static_cast<T>(value); }
		constexpr static Type mod() { return M::value; }

		template <typename T>
		static Type normalize(const T &x) {
			Type v;
			if (-mod() <= x && x < mod()) {
				v = static_cast<Type>(x);
			}
			else {
				v = static_cast<Type>(x % mod());
			}
			if (v < 0) {
				v += mod();
			}
			return v;
		}

		Modular& operator++() { return *this += 1; }
		Modular& operator--() { return *this -= 1; }
		Modular operator++(int) { Modular res(*this); *this += 1; return res; }
		Modular operator--(int) { Modular res(*this); *this -= 1; return res; }
		Modular operator-() const { return Modular(-value); }

		Modular& operator+=(const Modular &other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
		template <typename T> Modular& operator+=(const T &other) { return *this += Modular(other); }

		Modular& operator-=(const Modular &other) { if ((value -= other.value) < 0) value += mod(); return *this; }
		template <typename T> Modular& operator-=(const T &other) { return *this -= Modular(other); }

		template <typename T = M>
		typename enable_if<is_same<typename Modular<T>::Type, int>::value, Modular>::type& operator*=(const Modular &other) {
			value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(other.value));
			return *this;
		}
		template <typename T = M>
		typename enable_if<is_same<typename Modular<T>::Type, int64_t>::value, Modular>::type& operator*=(const Modular &other) {
			int64_t q = int64_t(static_cast<long double>(value) * other.value / mod());
			value = normalize(value * other.value - q * mod());
			return *this;
		}
		template <typename T = M>
		typename enable_if<!is_integral<typename Modular<T>::Type>::value, Modular>::type& operator*=(const Modular &other) {
			value = normalize(value * other.value);
			return *this;
		}

		Modular& operator/=(const Modular &other) { return *this *= inverse(other); }

		template <typename T> friend Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }
		template <typename T, typename U> friend Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }
		template <typename T, typename U> friend Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }
		 
		template <typename T> friend Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }
		template <typename T, typename U> friend Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
		template <typename T, typename U> friend Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }
		 
		template <typename T> friend Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }
		template <typename T, typename U> friend Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
		template <typename T, typename U> friend Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }
		 
		template <typename T> friend Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }
		template <typename T, typename U> friend Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
		template <typename T, typename U> friend Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }

		template <typename T> friend bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }
		template <typename T, typename U> friend bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }
		template <typename T, typename U> friend bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }

		template <typename T> friend bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }
		template <typename T, typename U> friend bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }
		template <typename T, typename U> friend bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }

		template <typename T> friend bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }
		template <typename T> friend bool operator>(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value > rhs.value; }
		template <typename T> friend bool operator<=(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value <= rhs.value; }
		template <typename T> friend bool operator>=(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value >= rhs.value; }

		template <typename U, typename T>
		friend U& operator<<(U &stream, const Modular<T> &number) {
			return stream << number();
		}

		template <typename U, typename T>
		friend U& operator>>(U &stream, Modular<T> &number) {
			typename common_type<typename Modular<T>::Type, int64_t>::type x;
			stream >> x;
			number.value = Modular<T>::normalize(x);
			return stream;
		}

		template <typename T, typename U>
		friend Modular<T> power(Modular<T> a, U b) {
			assert(b >= 0);
			Modular<T> res = 1;
			while (b) {
				if (b & 1) {
					res *= a;
				}
				a *= a;
				b >>= 1;
			}
			return res;
		}

		template<typename T>
		friend Modular<T> inverse(const Modular<T> &a) {
			assert(a.value != 0);
			return power(a, mod() - 2);
		}

		template <typename T>
		friend string to_string(const Modular<T> &number) {
		  return to_string(number());
		}

	private:
		Type value; 
	};

	//constexpr int MOD = 998244353;
	constexpr int MOD = 1000000007;
	using Mint = Modular<integral_constant<decay<decltype(MOD)>::type, MOD>>;

	/*
	// Dynamic Modular
	using ModType = int;
	struct VarMod { static ModType value; };
	ModType VarMod::value = 1000000007;
	ModType &MOD = VarMod::value;
	using Mint = Modular<VarMod>;
	*/

	struct Comb {
		int n;
		vector<Mint> _fact;
		vector<Mint> _inv_fact;
		vector<Mint> _inv;
		
		Comb() : n{0}, _fact{1}, _inv_fact{1}, _inv{0} {}
		Comb(int _n) : Comb() {
			init(_n);
		}
		
		void init(int m) {
			if (m <= n) {
				return;
			}
			_fact.resize(m + 1);
			_inv_fact.resize(m + 1);
			_inv.resize(m + 1);
			
			for (int i = n + 1; i <= m; i++) {
				_fact[i] = _fact[i - 1] * i;
			}
			_inv_fact[m] = inverse(_fact[m]);
			for (int i = m; i > n; i--) {
				_inv_fact[i - 1] = _inv_fact[i] * i;
				_inv[i] = _inv_fact[i] * _fact[i - 1];
			}
			n = m;
		}
		
		Mint fact(int m) {
			if (m > n) {
				init(2 * m);
			}
			return _fact[m];
		}
		Mint inv_fact(int m) {
			if (m > n) {
				init(2 * m);
			}
			return _inv_fact[m];
		}
		Mint inv(int m) {
			if (m > n) {
				init(2 * m);
			}
			return _inv[m];
		}
		Mint comb(int m, int k) {
			if (k < 0 || k > m) {
				return 0;
			}
			return fact(m) * inv_fact(k) * inv_fact(m - k);
		}
	} comb;
	${0}

snippet matrix "Struct Matrix" 
	template <typename T>
	struct matrix {
		int n, m;
		vector<vector<T>> mat;

		matrix() : n(0), m(0) {}
		matrix(int _n, int _m) {
			n = _n; 
			m = _m; 
			mat.assign(n, vector<T>(m, 0));
		}
		matrix(int _n, int _m, const T &val) {
			n = _n; 
			m = _m; 
			mat.assign(n, vector<T>(m, val));
		}
		matrix(vector<vector<T>> v) {
			n = v.size(); 
			m = v[0].size();
			mat = v;
		}

		inline void make_unit() {
			assert(n == m);
			for (int i = 0; i < n; i++)  {
				for (int j = 0; j < n; j++) {
					mat[i][j] = (i == j);
				}
			}
		}

		inline matrix operator + (const matrix &b) {
			assert(n == b.n && m == b.m);
			matrix res = (n, m);
			for(int i = 0; i < n; i++) {
				for(int j = 0; j < m; j++) {
					res.mat[i][j] = mat[i][j] + b.mat[i][j];
				}
			}
			return res; 
		} 
		inline matrix operator - (const matrix &b) {
			assert(n == b.n && m == b.m);
			matrix res = matrix(n, m);
			for(int i = 0; i < n; i++) {
				for(int j = 0; j < m; j++) {
					res.mat[i][j] = mat[i][j] - b.mat[i][j];
				}
			}
			return res;
		}
		inline matrix operator * (const matrix &b) {
			assert(m == b.n);
			matrix res = matrix(n, b.m);
			for(int i = 0; i < n; i++) {
				for(int j = 0; j < b.m; j++) {
					for(int k = 0; k < m; k++) {
						res.mat[i][j] += mat[i][k] * b.mat[k][j];
					}
				}
			}
			return res;
		}
		inline matrix pow(matrix a, int64_t b) {
			assert(n == m);
			matrix res(n, n); 
			res.make_unit();
			while (b) {
				if (b & 1) {
					res *= a;
				}
				a *= a;
				b >>= 1;
			}
			return res;
		}

		inline matrix& operator += (const matrix &b) { return *this = (*this) + b; }
		inline matrix& operator -= (const matrix &b) { return *this = (*this) - b; }
		inline matrix& operator *= (const matrix &b) { return *this = (*this) * b; }
		inline bool operator == (const matrix &b) { return mat == b.mat; }
		inline bool operator != (const matrix &b) { return mat != b.mat; }
	};
	${0}

snippet segmented_sieve "Segmented Sieve of Eratosthenes" 
	bitset<N> is_prime; // is_prime._Find_next(p); is_prime._Find_first();
	void segmented_sieve(int n) {
		int sq = sqrt(n) + 1;
		is_prime[0] = is_prime[1] = 1;
		vector<array<int, 2>> small_primes;
		for (int i = 2; i <= sq; i++) {
			if (!is_prime[i]) {
				small_primes.push_back({i, i * i});
				for (int j = i * i; j <= sq; j += i) {
					is_prime[j] = 1;
				}
			}
		}

		const int block_size = 1 << 18;
		for (int from = 0; from < n; from += block_size) {
			int to = min(from + block_size - 1, n - 1);
			for (array<int, 2> &p : small_primes) {
				for (; p[1] <= to; p[1] += p[0]) {
					is_prime[p[1]] = 1;
				}
			}
		}
		is_prime.flip();
	}
	${0}

snippet miller_rabin "Miller Rabin (Check a Numbes is Prime)"
	using u128 = __uint128_t;
	int64_t binpow(int64_t a, int64_t b, int64_t m) {
		int64_t res = 1;
		a %= m;
		while (b) {
			if (b & 1) {
				res = (u128)res * a % m;
			}
			a = (u128)a * a % m;
			b >>= 1;
		}
		return res;
	}

	bool check_composite(int64_t n, int64_t a, int64_t d, int s) {
		int64_t x = binpow(a, d, n);
		if (x == 1 || x == n - 1) {
			return false;
		}
		for (int r = 1; r < s; r++) {
			x = (u128)x * x % n;
			if (x == n - 1) {
				return false;
			}
		}
		return true;
	}

	bool miller_rabin(int64_t n) { // returns true if n is prime
		if (n < 2) {
			return false;
		}

		int r = 0;
		int64_t d = n - 1;
		while ((d & 1) == 0) {
			d >>= 1;
			r++;
		}

		for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
			if (n == a) {
				return true;
			}
			if (check_composite(n, a, d, r)) {
				return false;
			}
		}
		return true;
	}
	${0}

snippet convert_base "Cnovert Base [2-36]" 
	int64_t convert_to_10(const string &input, int base) {
		assert(base >= 2 && base <= 36);
		
		bool is_neg = (input[0] == '-'); 
		int start = input.length() - 1;
		int end = is_neg ? 1 : 0;

		int64_t res = 0, digit_value = 1;
		for(int i = start; i >= end; i--) {
			char c = input[i];
			
			if (c >= '0' && c <= '9') {
				c -= '0';
			}
			else {
				c = c - 'A' + 10;
			}
			assert(c < base);
			
			res += c * digit_value;
			digit_value *= base;
		}
		
		if (is_neg) {
			res *= -1;
		}
		
		return res;
	}

	string convert_from_10(int64_t value, int base) {
		assert(base >= 2 && base <= 36);
		
		bool is_neg = (value < 0);
		if (is_neg) {
			value *= -1;
		}
		
		string res;
		do {
			char digit = value % base;
		 
			if (digit < 10) {
				digit += '0';
			}
			else {
				digit = digit + 'A' - 10;
			}
			res += digit;
			value /= base;
			
		} while (value > 0);
		
		if (is_neg) {
			res += '-';
		}
		reverse(res.begin(), res.end());

		return res;
	}

	string convert_base(const string input, int base_from, int base_to) {
		return convert_from_10(convert_to_10(input, base_from), base_to);
	}
	${0}

snippet move "Geometry Movement" 
    constexpr int dx[] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};
    constexpr int dy[] = {0, 0, -1, 1, -1, 1, -1, 1, 0};
    const string move = "UDLR";
    auto check = [&](int x, int y) -> bool {
        return x >= 0 && x < n && y >= 0 && y < m;
    };

snippet geo2d "Geometry 2D" 
	const double inf = 1e100;
	const double eps = 1e-9;
	const double PI = acos((double)-1.0);

	int sign(double x) { 
		return (x > eps) - (x < -eps);
	}
	template <typename T>
	int sign(T x) {
		return x == 0 ? 0 : x > 0 ? 1 : -1;
	}

	template <typename T>
	struct Point {
		T x, y;
		Point() : x(0), y(0) {}
		Point(const T &_x, const T &_y) : x(_x), y(_y) {}
		Point(const Point<T> &p) : x(p.x), y(p.y) {}

		template<typename U>
		operator Point<U>() const {
			return Point<U>(U(x), U(y));
		}

		Point operator-() const { return Point(-x, -y); }

		Point& operator+=(const Point &other) { x += other.x, y += other.y; return *this; }
		Point& operator-=(const Point &other) { x -= other.x, y -= other.y; return *this; }
		Point& operator*=(const T &other) { x *= other, y *= other; return *this; }
		Point& operator/=(const T &other) { x /= other, y /= other; return *this; }

		friend Point operator+(const Point<T> &lhs, const Point<T> &rhs) { return lhs += rhs; }
		friend Point operator-(const Point<T> &lhs, const Point<T> &rhs) { return lhs -= rhs; }
		friend Point operator*(const Point<T> &lhs, const T &rhs) { return lhs *= rhs; }
		friend Point operator*(const T &lhs, const Point<T> &rhs) { return rhs *= lhs; }
		friend Point operator/(const Point<T> &lhs, const T &rhs) { return lhs /= rhs; }

		friend bool operator==(const Point<T> &lhs, const Point<T> &rhs) { return sign(lhs.x - rhs.x) == 0 && sign(lhs.y - rhs.y) == 0; }
		friend bool operator!=(const Point<T> &lhs, const Point<T> &rhs) { return !(lhs == rhs); }
		friend bool operator<(const Point<T> &lhs, const Point<T> &rhs) { return sign(lhs.x - rhs.x) == 0 ? sign(lhs.y - rhs.y) == -1 : sign(lhs.x - rhs.x) == -1; }
		friend bool operator>(const Point<T> &lhs, const Point<T> &rhs) { return sign(lhs.x - rhs.x) == 0 ? sign(lhs.y - rhs.y) == 1 : sign(lhs.x - rhs.x) == 1; }
		friend bool operator<=(const Point<T> &lhs, const Point<T> &rhs) { return !(lhs > rhs); }
		friend bool operator>=(const Point<T> &lhs, const Point<T> &rhs) { return !(lhs < rhs); }

		template <typename U>
		friend U& operator<<(U &stream, const Point &p) {
			return stream << "(" << p.x << ", " << p.y << ")";
		}

		template <typename U>
		friend U& operator>>(U &stream, Point &p) {
			stream >> p.x >> p.y;
			return stream;
		}

		/*
		double norm() { return sqrt(x * x + y * y); }
		double norm2() { return x * x + y * y; }
		*/
	};

	using pt = Point<int>;
	${0}

snippet mex "Minimum Excluded(MEX), O(n)"
	template <typename T>
	int mex(vector<T> &v) {
		int n = v.size();
		vector<bool> f(n + 1);
		for (int x : v) {
			if (x <= n) {
				f[x] = 1;
			}
		}
		int mex = 0;
		while (f[mex]) {
			mex++;
		}
		return mex;
	}
	${0}

snippet mex2 "MEX with Update, build -> O(n*log(n)), update -> O(log(n))"
	template <typename T>
	struct Mex {
		vector<T> arr;
		map<T, int> frequency;
		set<T> missing_numbers;

		Mex(const vector<T> &_arr) : arr(_arr) {
			for (int i = 0; i <= (int)arr.size(); i++) {
				missing_numbers.insert(i);
			}
			for (auto v : arr) {
				frequency[v]++;
				missing_numbers.erase(v);
			}
		}

		void modify(int x, const T &v) {
			assert(x < (int)arr.size());
			if (--frequency[arr[x]] == 0) {
				missing_numbers.insert(arr[x]);
			}
			arr[x] = v;
			frequency[v]++;
			missing_numbers.erase(v);
		}
		T get() {
			return *missing_numbers.begin();
		}
	};
	${0}

snippet arpa "Offline RMQ (Arpa's Trick), O(n + q)"
    vector<vector<array<int, 2>>> queries(n);
    for (int i = 0; i < q; i++) {
        int l, r;
        cin >> l >> r;
        l--, r--;
        queries[r].push_back({l, i});
    }

    vector<int> par(n, -1);
    auto find_set = [&](auto &&self, int v) -> int {
        return par[v] == -1 ? v : par[v] = self(self, par[v]);
    };

    vector<int> ans(q);
    stack<int> s;
    for (int i = 0; i < n; i++) {
        while (!s.empty() && a[s.top()] > a[i]) {
            par[s.top()] = i;
            s.pop();
        }
        s.push(i);
        for (auto [l, ind] : queries[i]) {
            ans[ind] = a[find_set(find_set, l)];
        }
    }

