snippet snippets "Snippets for c++"
	/*
	#Basics#
	beg0
	beg1
	beg2
	debug

	#Data Structures#
	mstack
	mqueue
	sparse
	dsu
	fenwick1
	fenwick2
	fenwick3
	segtree
	segtreelazy
	segtree2d
	ordered_set

	#Graph#
	dfs
	bfs
	topsort
	scc
	dcycle
	ucycle
	art_points
	bridges
	centroids
	euler_tour
	floyd
	dijkstra
	bellman
	spfa
	prim
	kruskal
	twosat	

	#String#
	split
	strip
	zfunction
	manacher
	suffix_array

	#Math#
	mint
	comb
	matrix
	sieve
	segmented_sieve
	miller_rabin
	convert_base
	pw

	#Geometry#
	table
	geo2d

	#Miscellaneous#
	arpa
	*/
	${0}

snippet beg0 "Start Template 0"
	#include <bits/stdc++.h>
	using namespace std;

	#pragma GCC optimize ("O3")
	#pragma GCC target ("sse4")

	using ll = long long;

	template <typename T> using pqg = priority_queue<T>;
	template <typename T> using pql = priority_queue<T, vector<T>, greater<T>>;

	template <typename T> bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
	template <typename T> bool cmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }

	mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
	#define uid(a, b) uniform_int_distribution<int64_t>(a, b)(rng)

	#ifdef DEBUG
	#include "/home/mohammad/code/debug.h"
	#else
	#define dbg(...)
	#define dbgarr(...)
	#endif

	void solve() {
		${0}	
	}

	int32_t main() {
		ios_base::sync_with_stdio(false);
		cin.tie(nullptr);

		int t = 1;
		$1cin >> t;

		while (t--) {
			solve();
		}

		return 0;
	}

snippet beg1 "Start Template 1"
	#include <bits/stdc++.h>
	using namespace std;

	#ifdef DEBUG
	#include "/home/mohammad/code/debug.h"
	#else
	#define dbg(...)
	#define dbgarr(...)
	#endif

	void solve() {
		${0}	
	}

	int32_t main() {
		ios_base::sync_with_stdio(false);
		cin.tie(nullptr);

		int t = 1;
		$1cin >> t;

		while (t--) {
			solve();
		}

		return 0;
	}

snippet beg2 "Start Template 2"
	#include <bits/stdc++.h>
	using namespace std;

	void solve() {
		${0}	
	}

	int32_t main() {
		ios_base::sync_with_stdio(false);
		cin.tie(nullptr);

		int t = 1;
		$1cin >> t;

		while (t--) {
			solve();
		}

		return 0;
	}

snippet debug "Debug Template"
	#define dbg(...) cerr << __DEBUG_UTIL__::outer << __LINE__ << ": [", __DEBUG_UTIL__::printer(#__VA_ARGS__, __VA_ARGS__)
	#define dbgarr(...) cerr << __DEBUG_UTIL__::outer << __LINE__ << ": [", __DEBUG_UTIL__::printerArr(#__VA_ARGS__, __VA_ARGS__)

	namespace __DEBUG_UTIL__ {
		bool colored_output = false; 
		string white = colored_output ? "\033[0;m" : "";
		string outer = colored_output ? "\033[0;31m" : "";     // red
		string var_name = colored_output ? "\033[1;34m" : "";  // blue
		string var_value = colored_output ? "\033[1;32m" : ""; // green

		template <typename T>
		concept is_iterable = requires(T &&x) { begin(x); } && !is_same_v<remove_cvref_t<T>, string>;

		void print(const char *x) { 
			cerr << x; 
		}
		void print(char x) { 
			cerr << "\'" << x << "\'"; 
		}
		void print(bool x) { 
			cerr << (x ? "T" : "F"); 
		}
		void print(string x) { 
			cerr << "\"" << x << "\"";
		}

		void print(vector<bool> &&v) { 
			/* Overloaded this because stl optimizes vector<bool> by using
			 _Bit_reference instead of bool to conserve space. */
			int f = 0;
			cerr << '{';
			for (auto &&i : v) {
				cerr << (f++ ? "," : "") << (i ? "T" : "F");
			}
			cerr << "}";
		}

		template <typename T>
		void print(T &&x) {
			if constexpr (is_iterable<T>) {
				if (size(x) && is_iterable<decltype(*(begin(x)))>) { 
					/* Iterable inside Iterable */
					int f = 0;
					cerr << "\n~~~~~\n";
					int w = max(0, (int)log10(size(x) - 1)) + 2;
					for (auto &&i : x) {
						cerr << setw(w) << left << f++, print(i), cerr << "\n";
					}
					cerr << "~~~~~\n";
				}
				else { 
					/* Normal Iterable */
					int f = 0;
					cerr << "{";
					for (auto &&i : x) {
						cerr << (f++ ? "," : ""), print(i);
					}
					cerr << "}";
				}
			}
			else if constexpr (requires { x.pop(); }) {
				/* Stacks, Priority Queues, Queues */
				auto temp = x;
				int f = 0;
				cerr << "{";
				if constexpr (requires { x.top(); }) {
					while (!temp.empty()) {
						cerr << (f++ ? "," : ""), print(temp.top()), temp.pop();
					}
				}
				else {
					while (!temp.empty()) {
						cerr << (f++ ? "," : ""), print(temp.front()), temp.pop();
					}
				}
				cerr << "}";
			}
			else if constexpr (requires { x.first; x.second; }) {
				/* Pair */
				cerr << '(', print(x.first), cerr << ',', print(x.second), cerr << ')';
			}
			else if constexpr (requires { get<0>(x); }) {
				/* Tuple */
				int f = 0;
				cerr << '(', apply([&f](auto... args) {
								  ((cerr << (f++ ? "," : ""), print(args)), ...);
							 }, x);
				cerr << ')';
			}
			else {
				cerr << x;
			}
		}

		template <typename T, typename... V>
		void printer(const char *names, T &&head, V &&...tail) {
			int i = 0;
			for (size_t bracket = 0; names[i] != '\0' and (names[i] != ',' or bracket != 0); i++) {
				if (names[i] == '(' or names[i] == '<' or names[i] == '{') {
					bracket++;
				}
				else if (names[i] == ')' or names[i] == '>' or names[i] == '}') {
					bracket--;
				}
			}
			cerr << var_name;
			cerr.write(names, i) << outer << " = " << var_value;
			print(head);
			if constexpr (sizeof...(tail)) {
				cerr << outer << " ||", printer(names + i + 1, tail...);
			}
			else {
				cerr << outer << "]\n" << white;
			}
		}

		template <typename T, typename... V>
		void printerArr(const char *names, T arr[], size_t N, V... tail) {
			size_t i = 0;
			cerr << var_name;
			for (; names[i] and names[i] != ','; i++) {
				cerr << names[i];
			}
			for (i++; names[i] and names[i] != ','; i++);
			cerr << outer << " = " << var_value << "{";
			for (size_t ind = 0; ind < N; ind++) {
				cerr << (ind ? "," : ""), print(arr[ind]);
			}
			cerr << "}";
			if constexpr (sizeof...(tail)) {
				cerr << outer << " ||", printerArr(names + i + 1, tail...);
			}
			else {
				cerr << outer << "]\n" << white;
			}
		}
	}
	${0}

snippet mstack "Minimum Stack, O(1)" 
	template <typename T>
	struct MStack {
		stack<pair<T, T>> st;
		
		void push(T v) {
			T mn = st.empty() ? v : min(v, st.top().second);
			st.emplace(v, mn);
		}
		void pop() {
			st.pop();
		}
		T top() {
			return st.top().first;
		}
		T get() {
			return st.top().second;
		}
		bool empty() {
			return st.empty();
		}
		int size() {
			return st.size();
		}
	};
	${0}

snippet mqueue "Minimum Queue, O(1)" 
	template <typename T>
	struct MQueue {
		stack<pair<T, T>> st1, st2;
		
		void push(T v) {
			T mn = st1.empty() ? v : min(v, st1.top().second);
			st1.emplace(v, mn);
		}
		void pop() {
			if (st2.empty()) {
				while (!st1.empty()) {
					T v = st1.top().first;
					T mn = st2.empty() ? v : min(v, st2.top().second);
					st1.pop();
					st2.emplace(v, mn);
				}
			}
			st2.pop();
		}
		T front() {
			if (st2.empty()) {
				while (!st1.empty()) {
					T v = st1.top().first;
					T mn = st2.empty() ? v : min(v, st2.top().second);
					st1.pop();
					st2.emplace(v, mn);
				}
			}
			return st2.top().first;
		}
		T get() {
			if (st1.empty() || st2.empty()) {
				return st1.empty() ? st2.top().second : st1.top().second;
			}
			return min(st1.top().second, st2.top().second);
		}
		bool empty() {
			return st1.empty() && st2.empty();
		}
		int size() {
			return st1.size() + st2.size();
		}
	};
	${0}

snippet sparse "RMQ, build -> O(n*log(n)), query -> O(1)"
	// with global array is faster (2s vs 3s for n = 1e7)
	// constexpr n = 1e7, lg = 25; int t[n][lg];
	template <typename T>
	struct SparseTable {
		int n, lg;
		vector<vector<T>> t;

		SparseTable() {}
		SparseTable(const vector<T> &v) {
			build(v);
		}

		inline T f(const T &a, const T &b) const {
			return min(a, b);
		}
		void build(const vector<T> &v) {
			n = v.size();
			lg = __lg(n) + 2;
			t.assign(n, vector<T>(lg));

			for (int i = 0; i < n; i++) {
				t[i][0] = v[i];
			}
			for (int k = 1; k < lg; k++) {
				for (int i = 0; i + (1 << k) - 1 < n; i++) {
					t[i][k] = f(t[i][k - 1], t[i + (1 << (k - 1))][k - 1]);
				}
			}
		}
		T get(int l, int r) { 
			assert(l >= 0 && l <= r && r < n);
			int k = __builtin_clz(1) - __builtin_clz(r - l + 1);
			//int k = __builtin_clzll(1) - __builtin_clzll(r - l + 1);
			return f(t[l][k], t[r - (1 << k) + 1][k]);
		}
	};
	${0}

snippet dsu "Disjoint Set Union, O(1)" 
	struct DSU {
		vector<int> par, sz;
		int c;
		
		DSU(int n) : c(n) {
			par.resize(n);
			iota(par.begin(), par.end(), 0);
			sz.assign(n, 1);
		}

		void make(int a) {
			par[a] = a;
			sz[a] = 1;
			c++;
		}
		int find(int a) {
			return (par[a] == a ? a : (par[a] = find(par[a])));
		}
		bool same(int a, int b) {
			return find(a) == find(b);
		}
		void merge(int a, int b) {
			if ((a = find(a)) == (b = find(b))) {
				return;
			}
			if (sz[a] > sz[b]) {
				swap(a, b);
			}
			par[a] = b;
			sz[b] += sz[a];
			c--;
		}
		int size(int a) {
			return sz[find(a)];
		}
		int count() {
			return c;
		}
	};
	${0}

snippet fenwick1 "Point_Update & Range_Query, O(log(n))"
	template <typename T>
	struct FenwickTree {
		int n;
		vector<T> f;
		
		FenwickTree() {}
		FenwickTree(int _n) : n(_n) {
			f.assign(n, T{});
		}
		// O(n) Construction
		FenwickTree(const vector<T> &v) {
			n = v.size();
			f.assign(n, T{});
			for (int i = 0; i < n; i++) {
				f[i] += v[i];
				int r = i | (i + 1);
				if (r < n) {
					f[r] += f[i];
				}
			}
		}
		
		void modify(int x, const T &v) {
			assert(x >= 0 && x < n);
			for (int i = x; i < n; i = i | (i + 1)) {
				f[i] += v;
			}
		}
		T get(int x) {
			T ans{};
			for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {
				ans += f[i];
			}
			return ans;
		}
		T get(int l, int r) {
			assert(l >= 0 && l <= r && r < n);
			return get(r) - get(l - 1);
		}
		// Return Kth smallest element
		int select(const T &k) {
			int x = (1 << (__lg(n) + 1)) - 1;
			T sum{};
			for (int i = 1 << __lg(n); i; i >>= 1) {
				if (x >= n || sum + f[x] >= k) {
					x -= i;
				}
				else if (x + i < n && sum + f[x] + f[x + i] < k) {
					sum += f[x];
					x += i;
				}
			}
			if (sum + f[x] < k) {
				x++;
			}
			return x;
		}
	};
	${0}

snippet fenwick2 "Range_Update & Point_Query, O(log(n))"
	template <typename T>
	struct FenwickTree2 { 
		int n;
		vector<T> f;
		
		FenwickTree2() {}
		FenwickTree2(int _n) : n(_n) {
			f.assign(n, T{});
		}
		FenwickTree2(const vector<T> &v) {
			n = v.size();
			f.assign(n, T{});
			for (int i = 0; i < n; i++) {
				modify(i, i, v[i]);
			}
		}

		void modify(int x, T v) {
			for (int i = x; i < n; i = i | (i + 1)) {
				f[i] += v;
			}
		}
		void modify(int l, int r, T v) {
			assert(l >= 0 && l <= r && r < n);
			modify(l, v);
			modify(r + 1, -v);
		}
		T get(int x) {
			assert(x >= 0 && x < n);
			T ans = 0;
			for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {
				ans += f[i];
			}
			return ans;
		}
	};
	${0}

snippet fenwick3 "Range_Update & Range_Query, O(log(n))" 
	template <typename T>
	struct FenwickTree {
		int n;
		vector<T> f1, f2;
		
		FenwickTree() {}
		FenwickTree(int _n) : n(_n) {
			f1.assign(n, T{});
			f2.assign(n, T{});
		}
		FenwickTree(const vector<T> &v) {
			n = v.size();
			f1.assign(n, T{});
			f2.assign(n, T{});
			for (int i = 0; i < n; i++) {
				modify(i, i, v[i]);
			}
		}

		void add(int x, T mul, T add) {
			for (int i = x; i < n; i = i | (i + 1)) {
				f1[i] += mul;
				f2[i] += add;
			}
		}
		void modify(int l, int r, T v) {
			assert(l >= 0 && l <= r && r < n);
			add(l, v, -v * (l - 1));
			add(r, -v, v * r);
		}
		T get(int x) {
			T mul{}, add{};
			for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {
				mul += f1[i];
				add += f2[i];
			}
			return mul * x + add;
		}
		T get(int l, int r) {
			assert(l >= 0 && l <= r && r < n);
			return get(r) - get(l - 1);
		}
	};
	${0}

snippet segtree "Segment Tree, update & query -> O(log(n))"
	struct SegmentTree {
		struct Node {
			int64_t sum = 0;
			int mn = 2e9, cnt = 1;

			template <typename M>
			void init(const M &v) {
				sum = mn = v;
				cnt = 1;
			}
		};

		int n;
		vector<Node> tree;

		Node merge(const Node &a, const Node &b) const {
			Node res;
			res.sum = a.sum + b.sum;
			res.mn = min(a.mn, b.mn);
			res.cnt = (res.mn == a.mn ? a.cnt : 0) + (res.mn == b.mn ? b.cnt : 0);
			return res;
		}

		inline void pull(int x) {
			tree[x] = merge(tree[2 * x], tree[2 * x + 1]);
		}

		void build(int x, int l, int r) {
			if (l == r) {
				return;
			}
			int m = (l + r) >> 1;
			build(2 * x, l, m);
			build(2 * x + 1, m + 1, r);
			pull(x);
		}

		template <typename M>
		void build(int x, int l, int r, const vector<M> &v) {
			if (l == r) {
				tree[x].init(v[l]);
				return;
			}
			int m = (l + r) >> 1;
			build(2 * x, l, m, v);
			build(2 * x + 1, m + 1, r, v);
			pull(x);
		}

		template <typename M>
		void modify(int x, int l, int r, int p, const M &v) {
			if (l == r) {
				tree[x].init(v);
				return;
			}
			int m = (l + r) >> 1;
			if (p <= m) {
				modify(2 * x, l, m, p, v);
			}
			else {
				modify(2 * x + 1, m + 1, r, p, v);
			}
			pull(x);
		}
		
		Node get(int x, int l, int r, int ll, int rr) {
			if (ll <= l && r <= rr) {
				return tree[x];
			}
			int m = (l + r) >> 1;
			if (m >= rr) {
				return get(2 * x, l, m, ll, rr);
			}
			else if (m < ll) {
				return get(2 * x + 1, m + 1, r, ll, rr);
			}
			return merge(get(2 * x, l, m, ll, rr), get(2 * x + 1, m + 1, r, ll, rr));
		}

		int find_first_knowingly(int x, int l, int r, const function<bool(const Node&)> &f) {
			if (l == r) {
				return l;
			}
			int m = (l + r) >> 1;
			if (f(tree[2 * x])) {
				return find_first_knowingly(2 * x, l, m, f);
			} 
			return find_first_knowingly(2 * x + 1, m + 1, r, f);
		}

		int find_first(int x, int l, int r, int ll, int rr, const function<bool(const Node&)> &f) {
			if (ll <= l && r <= rr) {
				if (!f(tree[x])) {
					return -1;
				}
				return find_first_knowingly(x, l, r, f);
			}
			int m = (l + r) >> 1;
			int res = -1;
			if (m >= ll) {
				res = find_first(2 * x, l, m, ll, rr, f);
			}
			if (m < rr && res == -1) {
				res = find_first(2 * x + 1, m + 1, r, ll, rr, f);
			}
			return res;
		}

		int find_last_knowingly(int x, int l, int r, const function<bool(const Node&)> &f) {
			if (l == r) {
				return l;
			}
			int m = (l + r) >> 1;
			if (f(tree[2 * x + 1])) {
				return find_last_knowingly(2 * x + 1, m + 1, r, f);
			} 
			return find_last_knowingly(2 * x, l, m, f);
		}

		int find_last(int x, int l, int r, int ll, int rr, const function<bool(const Node&)> &f) {
			if (ll <= l && r <= rr) {
				if (!f(tree[x])) {
					return -1;
				}
				return find_last_knowingly(x, l, r, f);
			}
			int m = (l + r) >> 1;
			int res = -1;
			if (m < rr) {
				res = find_last(2 * x + 1, m + 1, r, ll, rr, f);
			}
			if (m >= ll && res == -1) {
				res = find_last(2 * x, l, m, ll, rr, f);
			}
			return res;
		}

		SegmentTree(int _n) : n(_n) {
			assert(n > 0);
			tree.resize(4 * n);
			build(1, 0, n - 1);
		}

		template <typename M>
		SegmentTree(const vector<M> &v) {
			n = v.size();
			assert(n > 0);
			tree.resize(4 * n);
			build(1, 0, n - 1, v);
		}

		Node get(int ll, int rr) {
			assert(ll >= 0 && ll <= rr && rr < n);
			return get(1, 0, n - 1, ll, rr);
		}

		Node get(int p) {
			assert(0 <= p && p < n);
			return get(1, 0, n - 1, p, p);
		}

		template <typename M>
		void modify(int p, const M &v) {
			assert(p >= 0 && p < n);
			modify(1, 0, n - 1, p, v);
		}

		// find_first and find_last call all FALSE elements
		// to the left (right) of the sought position exactly once
		// auto f = [&](const auto &info) { return info.mn == 0; }

		int find_first(int ll, int rr, const function<bool(const Node&)> &f) {
			assert(ll >= 0 && ll <= rr && rr < n);
			return find_first(1, 0, n - 1, ll, rr, f);
		}

		int find_last(int ll, int rr, const function<bool(const Node&)> &f) {
			assert(ll >= 0 && ll <= rr && rr < n);
			return find_last(1, 0, n - 1, ll, rr, f);
		}
	};
	${0}

snippet segtreelazy "Segment Tree with Lazy Propagation, update & query -> O(log(n))"
	struct LazySegmentTree {
		struct Node {
			int64_t mn = 2e9, cnt = 0;
			int64_t add = 0;

			template <typename M>
			void init(const M &v) {
				mn = v;
				cnt = 1;
			}
			template <typename M>
			void apply(int l, int r, const M &v) {
				mn += v;
				add += v;
				l = r, r = l;
			}
		};

		int n;
		vector<Node> tree;

		Node unite(const Node &a, const Node &b) const {
			Node res;
			res.mn = min(a.mn, b.mn);
			res.cnt = (res.mn == a.mn ? a.cnt : 0) + (res.mn == b.mn ? b.cnt : 0);
			return res;
		}

		inline void pull(int x) {
			tree[x] = unite(tree[2 * x], tree[2 * x + 1]);
		}

		inline void push(int l, int r, int x) {
			int m = (l + r) / 2;
			if (tree[x].add != 0) {
				tree[2 * x].apply(l, m, tree[x].add);
				tree[2 * x + 1].apply(m + 1, r, tree[x].add);
				tree[x].add = 0;
			}
		}

		void build(int x, int l, int r) {
			if (l == r) {
				return;
			}
			int m = (l + r) / 2;
			build(2 * x, l, m);
			build(2 * x + 1, m + 1, r);
			pull(x);
		}

		template <typename M>
		void build(int x, int l, int r, const vector<M> &v) {
			if (l == r) {
				tree[x].init(v[l]);
				return;
			}
			int m = (l + r) / 2;
			build(2 * x, l, m, v);
			build(2 * x + 1, m + 1, r, v);
			pull(x);
		}

		Node get(int x, int l, int r, int ll, int rr) {
			if (l >= ll && r <= rr) {
				return tree[x];
			}
			push(l, r, x);
			int m = (l + r) / 2;
			Node res{};
			if (m >= rr) {
				res = get(2 * x, l, m, ll, rr);
			} 
			else if (m < ll) {
				res = get(2 * x + 1, m + 1, r, ll, rr);
			} 
			else {
				res = unite(get(2 * x, l, m, ll, rr), get(2 * x + 1, m + 1, r, ll, rr));
			}
			pull(x);
			return res;
		}

		template <typename M>
		void modify(int x, int l, int r, int ll, int rr, const M &v) {
			if (l >= ll && r <= rr) {
				tree[x].apply(l, r, v);
				return;
			}
			push(l, r, x);
			int m = (l + r) / 2;
			if (m >= ll) {
				modify(2 * x, l, m, ll, rr, v);
			}
			if (m < rr) {
				modify(2 * x + 1, m + 1, r, ll, rr, v);
			}
			pull(x);
		}

		int find_first_knowingly(int x, int l, int r, const function<bool(const Node&)> &f) {
			if (l == r) {
				return l;
			}
			push(l, r, x);
			int m = (l + r) / 2;
			int res;
			if (f(tree[2 * x])) {
				res = find_first_knowingly(2 * x, l, m, f);
			} 
			else {
				res = find_first_knowingly(2 * x + 1, m + 1, r, f);
			}
			pull(x);
			return res;
		}

		int find_first(int x, int l, int r, int ll, int rr, const function<bool(const Node&)> &f) {
			if (ll <= l && r <= rr) {
				if (!f(tree[x])) {
					return -1;
				}
				return find_first_knowingly(x, l, r, f);
			}
			push(l, r, x);
			int m = (l + r) / 2;
			int res = -1;
			if (m >= ll) {
				res = find_first(2 * x, l, m, ll, rr, f);
			}
			if (m < rr && res == -1) {
				res = find_first(2 * x + 1, m + 1, r, ll, rr, f);
			}
			pull(x);
			return res;
		}

		int find_last_knowingly(int x, int l, int r, const function<bool(const Node&)> &f) {
			if (l == r) {
				return l;
			}
			push(l, r, x);
			int m = (l + r) / 2;
			int res;
			if (f(tree[2 * x + 1])) {
				res = find_last_knowingly(2 * x + 1, m + 1, r, f);
			} 
			else {
				res = find_last_knowingly(2 * x, l, m, f);
			}
			pull(x);
			return res;
		}

		int find_last(int x, int l, int r, int ll, int rr, const function<bool(const Node&)> &f) {
			if (ll <= l && r <= rr) {
				if (!f(tree[x])) {
					return -1;
				}
				return find_last_knowingly(x, l, r, f);
			}
			push(l, r, x);
			int m = (l + r) / 2;
			int res = -1;
			if (m < rr) {
				res = find_last(2 * x + 1, m + 1, r, ll, rr, f);
			}
			if (m >= ll && res == -1) {
				res = find_last(2 * x, l, m, ll, rr, f);
			}
			pull(x);
			return res;
		}

		LazySegmentTree(int _n) : n(_n) {
			assert(n > 0);
			tree.resize(4 * n);
			build(1, 0, n - 1);
		}

		template <typename M>
		LazySegmentTree(const vector<M> &v) {
			n = v.size();
			assert(n > 0);
			tree.resize(4 * n);
			build(1, 0, n - 1, v);
		}

		Node get(int ll, int rr) {
			assert(0 <= ll && ll <= rr && rr <= n - 1);
			return get(1, 0, n - 1, ll, rr);
		}

		Node get(int p) {
			assert(0 <= p && p <= n - 1);
			return get(1, 0, n - 1, p, p);
		}

		template <typename M>
		void modify(int ll, int rr, const M &v) {
			assert(0 <= ll && ll <= rr && rr <= n - 1);
			modify(1, 0, n - 1, ll, rr, v);
		}

		// find_first and find_last call all FALSE elements
		// to the left (right) of the sought position exactly once
		// auto f = [&](const auto &info) { return info.mn == 0; };

		int find_first(int ll, int rr, const function<bool(const Node&)> &f) {
			assert(0 <= ll && ll <= rr && rr <= n - 1);
			return find_first(1, 0, n - 1, ll, rr, f);
		}

		int find_last(int ll, int rr, const function<bool(const Node&)> &f) {
			assert(0 <= ll && ll <= rr && rr <= n - 1);
			return find_last(1, 0, n - 1, ll, rr, f);
		}
	};
	${0}

snippet segtree2d "Segment Tree 2D"
	class segtree_2d {
	public:
		struct node {
			int64_t sum = 0;
			int mn = 0;
			int cnt = 1;

			void apply(int v) {
				mn = v;
				sum = v;
			}
		};

		node unite(const node &a, const node &b) const {
			node res;
			res.sum = a.sum + b.sum;
			res.mn = min(a.mn, b.mn);
			res.cnt = (res.mn == a.mn ? a.cnt : 0) + (res.mn == b.mn ? b.cnt : 0);
			return res;
		}

		inline void pull_x(int x, int y) {
			tree[x][y] = unite(tree[x * 2][y], tree[x * 2 + 1][y]);
		}

		inline void pull_y(int x, int y) {
			tree[x][y] = unite(tree[x][y * 2], tree[x][y * 2 + 1]);
		}

		int n, m;
		vector<vector<node>> tree;

		void build_y(int x, int lx, int rx, int y, int ly, int ry) {
			if (ly == ry) {
				if (lx == rx) {
					return;
				}
				else {
					pull_x(x, y);
				}
				return;
			} 
			int my = (ly + ry) / 2;
			build_y(x, lx, rx, y * 2, ly, my);
			build_y(x, lx, rx, y * 2 + 1, my + 1, ry);
			pull_y(x, y);
		}

		void build_x(int x, int lx, int rx) {
			if (lx != rx) {
				int mx = (lx + rx) / 2;
				build_x(x * 2, lx, mx);
				build_x(x * 2 + 1, mx + 1, rx);
			}
			build_y(x, lx, rx, 1, 0, m - 1);
		}

		template <typename M>
		void build_y(int x, int lx, int rx, int y, int ly, int ry, const vector<vector<M>> &v) {
			if (ly == ry) {
				if (lx == rx) {
					tree[x][y].apply(v[lx][ly]);
				}
				else {
					pull_x(x, y);
				}
				return;
			} 
			int my = (ly + ry) / 2;
			build_y(x, lx, rx, y * 2, ly, my, v);
			build_y(x, lx, rx, y * 2 + 1, my + 1, ry, v);
			pull_y(x, y);
		}

		template <typename M>
		void build_x(int x, int lx, int rx, const vector<vector<M>> &v) {
			if (lx != rx) {
				int mx = (lx + rx) / 2;
				build_x(x * 2, lx, mx, v);
				build_x(x * 2 + 1, mx + 1, rx, v);
			}
			build_y(x, lx, rx, 1, 0, m - 1, v);
		}

		void modify_y(int x, int lx, int rx, int y, int ly, int ry, int px, int py, const int v) {
			if (ly == ry) {
				if (lx == rx) {
					tree[x][y].apply(v);
				}
				else {
					pull_x(x, y);
				}
			} 
			else {
				int my = (ly + ry) / 2;
				if (py <= my) {
					modify_y(x, lx, rx, y * 2, ly, my, px, py, v);
				}
				else {
					modify_y(x, lx, rx, y * 2 + 1, my + 1, ry, px, py, v);
				}
				pull_y(x, y);
			}
		}

		void modify_x(int x, int lx, int rx, int px, int py, const int v) {
			if (lx != rx) {
				int mx = (lx + rx) / 2;
				if (px <= mx) {
					modify_x(x * 2, lx, mx, px, py, v);
				}
				else {
					modify_x(x * 2 + 1, mx + 1, rx, px, py, v);
				}
			}
			modify_y(x, lx, rx, 1, 0, m - 1, px, py, v);
		}

		node get_y(int x, int y, int ly, int ry, int lly, int rry) {
			if (lly <= ly && ry <= rry) {
				return tree[x][y];
			}
			int my = (ly + ry) / 2;
			if (my >= rry) {
				return get_y(x, y * 2, ly, my, lly, rry);
			}
			else if (my < lly) {
				return get_y(x, y * 2 + 1, my + 1, ry, lly, rry);
			}
			return unite(get_y(x, y * 2, ly, my, lly, rry), get_y(x, y * 2 + 1, my + 1, ry, lly, rry));
		}

		node get_x(int x, int lx, int rx, int llx, int rrx, int lly, int rry) {
			if (llx <= lx && rx <= rrx) {
				return get_y(x, 1, 0, m - 1, lly, rry);
			}
			int mx = (lx + rx) / 2;
			if (mx >= rrx) {
				return  get_x(x * 2, lx, mx, llx, rrx, lly, rry);
			}
			else if (mx < llx) {
				return get_x(x * 2 + 1, mx + 1, rx, llx, rrx, lly, rry);
			}
			return unite(get_x(x * 2, lx, mx, llx, rrx, lly, rry), get_x(x * 2 + 1, mx + 1, rx, llx, rrx, lly, rry));
		}

		segtree_2d(int _n, int _m) : n(_n), m(_m) {
			assert(n > 0 && m > 0);
			tree.assign(4 * n, vector<node>(4 * m));
			build_x(1, 0, n - 1);
		}

		template <typename M>
		segtree_2d(const vector<M> &v) {
			n = v.size();
			m = v[0].size();
			assert(n > 0 && m > 0);
			tree.assign(4 * n, vector<node>(4 * m));
			build_x(1, 0, n - 1, v);
		}

		node get(int llx, int rrx, int lly, int rry) {
			assert(0 <= llx && llx <= rrx && rrx <= n - 1);
			assert(0 <= lly && lly <= rry && rry <= m - 1);
			return get_x(1, 0, n - 1, llx, rrx, lly, rry);
		}

		node get(int px, int py) {
			assert(0 <= px && px <= n - 1);
			assert(0 <= py && py <= m - 1);
			return get_x(1, 0, n - 1, px, px, py, py);
		}

		void modify(int px, int py, const int v) {
			assert(px >= 0 && px <= n - 1);
			assert(py >= 0 && py <= m - 1);
			modify_x(1, 0, n - 1, px, py, v);
		}
	};
	${0}

snippet ordered_set "Ordered Set & Ordered Map"
	// s.order_of_key(k) -> number of elements less than k 
	// *s.find_by_order(index) -> s[index]
	#include <ext/pb_ds/assoc_container.hpp>
	#include <ext/pb_ds/tree_policy.hpp>
	using namespace __gnu_pbds;
	template <typename T>
	using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
	template <typename T, typename R> 
	using ordered_map = tree<T, R, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
	${0}

snippet dfs "Depth First Search, O(n + m)" 
    vector<bool> vis(n);
    vector<int> in(n), out(n), order;
    int timer = 0;
    auto dfs = [&](auto &&self, int v) -> void {
        vis[v] = true;
        in[v] = timer++;
        order.push_back(v);
        for (auto u : adj[v]) {
            if (!vis[u]) {
                self(self, u);
            }
        }
        out[v] = timer;
    };

snippet bfs "Breadth First Search, O(n + m)" 
    vector<bool> vis(n);
    vector<int> dist(n), par(n);
    auto bfs = [&](int s) -> void {
        queue<int> q;
        q.push(s);
        vis[s] = true;
        dist[s] = 0;
        par[s] = -1;
        while (!q.empty()) {
            int v = q.front();
            q.pop();

            for (auto u : adj[v]) {
                if (!vis[u]) {
                    q.push(u);
                    vis[u] = true;
                    dist[u] = dist[v] + 1;
                    par[u] = v;
                }
            }
        }
    };

snippet topsort "Topological Sorting, O(n + m)"
    // An order of vertices in DAG that every edge leads from 
    // the vertex with a smaller index to a vertex with a larger one.
    vector<bool> vis(n);
    vector<int> ord;
    auto dfs = [&](auto &&self, int v) -> void {
        vis[v] = true;
        for (auto u : adj[v]) {
            if (!vis[u]) {
                self(self, u);
            }
        }
        ord.push_back(v);
    };
    auto topological_sorting = [&]() -> void {
        for (int v = 0; v < n; v++) {
            if (!vis[v]) {
                dfs(dfs, v);
            }
        }
        reverse(ord.begin(), ord.end());
    };

snippet scc "Strong Connected Components" 
	vector<int> order, component, root_nodes, roots(N), adj_scc[N];

	void dfs1(int u) {
		vis[u] = true;

		for (auto &v : adj[u]) {
			if (!vis[v]) {
				dfs1(v);
			}
		}
		order.push_back(u);
	}

	void dfs2(int u) {
		vis[u] = true;
		component.push_back(u);

		for (auto &v : adj_rev[u]) { 
			if (!vis[v]) {
				dfs2(v);
			}
		}
	}

	void scc(int n) {
		order.clear();
		root_nodes.clear();

		for (int u = 0; u < n; u++) {
			if (!vis[u]) {
				dfs1(u);
			}
		}
		reverse(order.begin(), order.end());

		fill(vis, vis + n, false);
		for (auto &u : order) {
			if (!vis[u]) {
				dfs2(u);
				int root = component.front();
				for (auto &v : component) {
					roots[v] = root;
				}
				root_nodes.push_back(root);

				adj_scc[root].clear();
				component.clear();
			}
		}
		
		for (int u = 0; u < n; u++) {
			for (auto &v : adj[u]) {
				int root_u = roots[u], root_v = roots[v];
				if (root_u != root_v) {
					adj_scc[root_u].push_back(root_v);
				}
			}
		}
	}
	${0}

snippet dcycle "Find Cycle in Directed Graph, O(n + m)" 
    vector<int> color(n), par(n, -1), cycle;
    int cycle_start, cycle_end;
    auto dfs = [&](auto &&self, int v) -> bool {
        color[v] = 1;
        for (auto u : adj[v]) {
            if (color[u] == 0) {
                par[u] = v;
                if (self(self, u)) {
                    return true;
                }
            } 
            else if (color[u] == 1) {
                cycle_end = v;
                cycle_start = u;
                return true;
            }
        }
        color[v] = 2;
        return false;
    };
    auto find_cycle = [&]() -> bool {
        cycle.clear();
        cycle_start = -1;
        for (int v = 0; v < n; v++) { 
            if (color[v] == 0 && dfs(dfs, v)) {
                break;
            }
        }
        if (cycle_start == -1) {
            return false;
        }

        for (int v = cycle_end; v != cycle_start; v = par[v]) {
            cycle.push_back(v);
        }
        cycle.push_back(cycle_start);
        reverse(cycle.begin(), cycle.end());
        return true;
    };

snippet ucycle "Find Cycle in Undirected Graph, O(n + m)" 
    vector<bool> vis(n);
    vector<int> par(n, -1), cycle;
    int cycle_start, cycle_end;
    auto dfs = [&](auto &&self, int v, int p) -> bool {
        vis[v] = true;
        for (auto u : adj[v]) {
            if (u == p) {
                continue; 
            }
            if (vis[u]) {
                cycle_end = v;
                cycle_start = u;
                return true;
            }
            par[u] = v;
            if (self(self, u, par[u])) {
                return true;
            }
        }
        return false;
    };
    auto find_cycle = [&]() -> bool {
        cycle.clear();
        cycle_start = -1;
        for (int v = 0; v < n; v++) {
            if (!vis[v] && dfs(dfs, v, par[v])) {
                break;
            }
        }
        if (cycle_start == -1) {
            return false;
        } 

        for (int v = cycle_end; v != cycle_start; v = par[v]) {
            cycle.push_back(v);
        }
        cycle.push_back(cycle_start);
        return true;
    };

snippet art_points "Find Articulation Points in Undirected Graph, O(n + m)" 
    vector<bool> vis(n);
    vector<int> tin(n), low(n), art_points;
    int timer = 0;
    auto dfs = [&](auto &&self, int v, int p) -> void {
        vis[v] = true;
        tin[v] = low[v] = timer++;
        int children = 0;
        for (auto u : adj[v]) {
            if (u == p) {
                continue;
            }
            if (vis[u]) {
                low[v] = min(low[v], tin[u]);
            } 
            else {
                self(self, u, v);
                low[v] = min(low[v], low[u]);
                if (low[u] >= tin[v] && p != -1) {
                    art_points.push_back(v);
                }
                children++;
            }
        }
        if (p == -1 && children > 1) {
            art_points.push_back(v);
        }
    };
    auto find_art_points = [&]() {
        for (int v = 0; v < n; v++) {
            if (!vis[v]) {
                dfs(dfs, v, -1);
            }
        }
        // Some points may be added several times
        sort(art_points.begin(), art_points.end());
        art_points.erase(unique(art_points.begin(), art_points.end()), art_points.end());
    };

snippet bridges "Find Articulation Bridges in Undirected Graph, O(n + m)" 
    vector<bool> vis(n);
    vector<array<int, 2>> bridges;
    vector<int> tin(n), low(n);
    int timer = 0;
    auto dfs = [&](auto &&self, int v, int p) -> void {
        vis[v] = true;
        tin[v] = low[v] = timer++;
        for (auto u : adj[v]) {
            if (u == p) {
                continue;
            }
            if (vis[u]) {
                low[v] = min(low[v], tin[u]);
            } 
            else {
                self(self, u, v);
                low[v] = min(low[v], low[u]);
                if (low[u] > tin[v]) {
                    bridges.push_back({v, u});
                }
            }
        }
    };
    auto find_bridges = [&]() -> void {
        for (int v = 0; v < n; v++) {
            if (!vis[v]) {
                dfs(dfs, v, -1);
            }
        }
    };

snippet centroids "Find Centroids of a tree, O(n + m)" 
    // A node such that when the tree is rooted at it, no other nodes have a subtree of size greater than n/2
    vector<int> sz(n), centroids;
    auto dfs = [&](auto &&self, int v, int p) -> void {
        sz[v] = 1;
        for (auto u : adj[v]) {
            if (u == p) {
                continue;
            }
            self(self, u, v);
            sz[v] += sz[u];
        }
    };
    auto find_centroids = [&]() -> void {
        int v = 0;
        dfs(dfs, v, -1);
        while (true) {
            int tmp = -1;
            for (auto u : adj[v]) {
                if (sz[u] > sz[v]) {
                    continue;
                }
                if (2 * sz[u] >= n) {
                    tmp = u;
                }
            }
            if (tmp == -1) {
                break;
            }
            v = tmp;
        }
        dfs(dfs, v, -1);
        for (auto u : adj[v]) {
            if (2 * sz[u] == n) {
                centroids.push_back(u);
                centroids.push_back(v);
                return;
            }
        }
        centroids.push_back(v);
    };

snippet euler_tour "Euler Tour Technique (ETT)" 
    // add x to node v and get sum subtree v: add(v, x) -> add(in[v], x), sum(v) -> sum(in[v], out[v])
    // add x to node v and get sum path v to root=0: add(v, x) -> add(in[v], x) add(out[v], -x), sum(v) -> sum(0, in[v])
    vector<int> in(n), out(n);
    int timer = 0;
    auto dfs = [&](auto &&self, int v, int p) -> void {
        in[v] = timer++;
        for (auto u : adj[v]) {
            if (u == p) {
                continue;
            }
            self(self, u, v);
        }
        out[v] = timer;
    };
    dfs(dfs, 0, -1);
	
snippet floyd "Find All Shortest Path, O(n^3)" 
    // Graph may have negative weight but no have negative weight cycle
    // if graph have negative weight cycle, exist a vertex v such that dist[v][v] < 0
    constexpr int64_t INF = 1e18;
    vector dist(n, vector<int64_t>(n, INF));
    for (int i = 0; i < n; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--, v--;
        dist[u][v] = w;
        dist[v][u] = w;
    }
    for (int i = 0; i < n; i++) {
        dist[i][i] = 0;
    }

    auto floyd_warshall = [&]() -> void {
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] < INF && dist[k][j] < INF) {
                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }
    };

snippet dijkstra "Single Source Shortest Path, O(m*log(n))"
    constexpr int64_t INF = 1e18;
    vector<int64_t> dist(n, INF), cnt(n, 0);
    vector<int> par(n, -1);
    auto dijkstra = [&](int s) -> void {
        priority_queue<pair<int64_t, int>, vector<pair<int64_t, int>>, greater<pair<int64_t, int>>> pq;
        pq.emplace(0, s);
        dist[s] = 0;
        cnt[s] = 1;
        while (!pq.empty()) {
            auto [dist_v, v] = pq.top();
            pq.pop();

            if (dist_v != dist[v]) {
                continue;
            }
            for (auto [u, w] : adj[v]) {
                if (dist[v] + w < dist[u]) {
                    dist[u] = dist[v] + w;
                    par[u] = v;
                    cnt[u] = cnt[v];
                    pq.emplace(dist[u], u);
                }
                else if (dist[v] + w == dist[u]) {
                    cnt[u] = (cnt[u] + cnt[v]); // MOD
                }
            }
        }
    };

snippet bellman "Bellman Ford" 
	struct Edge {
		int64_t u, v, w;
	}; 

	const int64_t INF = 4e18;
	vector<Edge> edges;
	vector<int> neg_path;
	int64_t d[N], p[N];

	// false -> exist negative cycle 
	bool bellman_ford(int s, int n) { // O(n*m)  
		fill(d, d + n, INF);
		fill(p, p + n, -1);
		neg_path.clear();

		d[s] = 0;
		int x = -1;
		for (int i = 0; i < n; i++) {
			x = -1;
			for (auto &e : edges) {
				if (d[e.u] < INF) {
					if (d[e.v] > d[e.u] + e.w) {
						d[e.v] = max(-INF, d[e.u] + e.w);
						p[e.v] = e.u;
						x = e.v;
					}
				}
			}
			if (x == -1) {
				return false;
			}
		}

		int y = x;
		for (int i = 0; i < n; i++) {
			y = p[y];
		}
		for (int cur = y; ; cur = p[cur]) {
			neg_path.push_back(cur);
			if (cur == y && int(neg_path.size()) > 1) {
				break;
			}
		}
		reverse(neg_path.begin(), neg_path.end());

		return true;
	}
	${0}

snippet spfa "SPFA (Shortest Path Fast Algorithm)" 
	const int64_t INF = 4e18;
	int64_t d[N], cnt[N];
	bool inq[N];

	// false -> exist negative cycle
	bool spfa(int s, int n) { // O(n*m)
		fill(d, d + n, INF);
		fill(cnt, cnt + n, 0);
		fill(inq, inq + n, 0);

		queue<int> q;
		q.push(s);
		d[s] = 0;
		inq[s] = true;
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			inq[u] = false;

			for (auto &e : adj[u]) {
				auto [v, w] = e.first;

				if (d[u] + w < d[v]) {
					d[v] = d[u] + w;
					if (!inq[v]) {
						q.push(v);
						inq[v] = true;
						cnt[v]++;
						if (cnt[v] > n) {
							return false; 
						}
					}
				}
			}
		}
		return true;
	}
	${0}

snippet prim "Prim MST" 
	const int INF = 1e9;
	struct Edge {
		int w = INF;
		int to = -1;
	};

	bool used[N];
	Edge mst[N];

	// complete graph, -1 -> not exist mst
	int64_t prim(int n) { // O(n^2)
		fill(used, used + n, 0);

		int64_t total_weight = 0;
		mst[0].w = 0;
		for (int i = 0; i < n; i++) {
			int u = -1;
			for (int j = 0; j < n; j++) {
				if (!used[j] && (u == -1 || mst[j].w < mst[u].w)) {
					u = j;
				}
			}
			if (mst[u].w == INF) {
				return -1;
			}

			used[u] = true;
			total_weight += mst[u].w;
			for (int v = 0; v < n; v++) {
				if (adj[u][v] < mst[v].w) {
					mst[v].to = u; 
					mst[v].w = adj[u][v];
				}
			}
		}
		
		return total_weight;
	}
	${0}

snippet kruskal "Kruskal MST" 
	struct Edge {
		int u, v, w;
		bool operator < (Edge const &other) {
			return w < other.w;
		}
	} edges[N]; 
	vector<Edge> result;

	struct dsu {
		vector<int> parent, sz;

		dsu(int n) {
			parent.resize(n); sz.resize(n);;
			for (int i = 0; i < n; i++) {
				make(i);
			}
		}

		void make(int a) {
			parent[a] = a;
			sz[a] = 1;
		}
		int find(int a) {
			return (parent[a] == a ? a : (parent[a] = find(parent[a])));
		}
		bool same(int a, int b) {
			return find(a) == find(b);
		}
		void merge(int a, int b) {
			if ((a = find(a)) != (b = find(b))) {
				if (sz[a] > sz[b]) {
					swap(a, b);
				}
				parent[a] = b;
				sz[b] += sz[a];
			}
		}
	};

	// -1 -> not exitst mst
	int64_t kruskal(int n, int m) { // O(m*log(n))
		result.clear();
		int64_t total_weight = 0;
		sort(edges, edges + m);

		dsu d(n);
		
		int nodes = 0;
		for (auto &e : edges) {
			if (!d.same(e.u, e.v)) {
				total_weight += e.w;
				result.push_back(e);
				d.merge(e.u, e.v);
				nodes++;
			}
			if (nodes == n - 1) {
				break;
			}
		}

		if (nodes != n - 1) {
			return -1;
		}
		return total_weight;
	}
	${0}

snippet towsat "2-SAT (Boolean satisfiability problem)"
	struct TwoSat {
		int n;
		vector<vector<int>> e;
		vector<bool> ans;

		TwoSat(int n) : n(n), e(2 * n), ans(n) {}

		void add_clause(int u, bool f, int v, bool g) {
			e[2 * u + !f].push_back(2 * v + g);
			e[2 * v + !g].push_back(2 * u + f);
		}
		bool satisfiable() {
			vector<int> id(2 * n, -1), dfn(2 * n, -1), low(2 * n, -1);
			vector<int> stk;
			int now = 0, cnt = 0;
			function<void(int)> tarjan = [&](int u) {
				stk.push_back(u);
				dfn[u] = low[u] = now++;
				for (auto v : e[u]) {
					if (dfn[v] == -1) {
						tarjan(v);
						low[u] = min(low[u], low[v]);
					} 
					else if (id[v] == -1) {
						low[u] = min(low[u], dfn[v]);
					}
				}
				if (dfn[u] == low[u]) {
					int v;
					do {
						v = stk.back();
						stk.pop_back();
						id[v] = cnt;
					} while (v != u);
					cnt++;
				}
			};
			for (int i = 0; i < 2 * n; i++) {
				if (dfn[i] == -1) {
					tarjan(i);
				}
			}
			for (int i = 0; i < n; i++) {
				if (id[2 * i] == id[2 * i + 1]) {
					return false;
				}
				ans[i] = id[2 * i] > id[2 * i + 1];
			}
			return true;
		}
		vector<bool> answer() { 
			return ans;
		}
	};
	${0}

snippet split "Split String, O(n)" 
	vector<string> split(const string &s, const char ch = ' ') {
		int n = s.size();
		vector<string> sp;

		string tmp = "";
		for (int i = 0; i < n; i++) {
			if (s[i] != ch) {
				tmp += s[i];
			}
			else if (tmp != "") {
				sp.push_back(tmp);
				tmp = "";
			}
		}
		if (tmp != "") {
			sp.push_back(tmp);
		}
		return sp;
	}
	${0}

snippet strip "Strip String, O(n)"
	string strip(const string &s, const char ch = ' ') {
		int n = s.size();
		while (n > 0 && s[n - 1] == ch) {
			n--;
		}

		string res = "";
		for (int i = 0; i < n; i++) {
			if (s[i] == ch) {
				continue;
			}
			while (i < n) {
				res += s[i];
				i++;
			}
		}
		return res;
	}
	${0}

snippet zfunction "Longest prefix start at index i that match with string s, O(n)"
	vector<int> z_function(const string &s) {
		int n = s.size();
		vector<int> z(n);
		int l = 0, r = 0;
		for (int i = 1; i < n; i++) {
			if (i < r) {
				z[i] = min(r - i, z[i - l]);
			}
			while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
				z[i]++;
			}
			if (i + z[i] > r) {
				l = i;
				r = i + z[i];
			}
		}
		return z;
	}
	${0}

snippet manacher "Find all sub-palindrome, O(n)" 
	// m_even[i] = (m[2i] - 1) / 2, m_odd[i] = m[2i + 1] / 2
	vector<int> manacher(const string &s) {
		string t = "#";
		for (auto c : s) {
			t += c;
			t += '#';
		}

		int n = t.size();
		vector<int> m(n);
		for (int i = 0, j = 0; i < n; i++) {
			if (2 * j - i >= 0 && j + m[j] > i) {
				m[i] = min(m[2 * j - i], j + m[j] - i);
			}
			while (i - m[i] >= 0 && i + m[i] < n && t[i - m[i]] == t[i + m[i]]) {
				m[i]++;
			}
			if (i + m[i] > j + m[j]) {
				j = i;
			}
		}
		return m;
	}
	${0}

snippet suffix_array "Suffix Array, build -> O(n*log(n)), lcp -> O(n)"
	// with global array is faster (2s vs 3s for n = 1e7)
	// constexpr n = 1e7, lg = 25; int t[n][lg];
	template <typename T>
	struct SparseTable {
		int n, lg;
		vector<vector<T>> t;

		SparseTable() {}
		SparseTable(const vector<T> &v) {
			build(v);
		}

		inline T f(const T &a, const T &b) const {
			return min(a, b);
		}
		void build(const vector<T> &v) {
			n = v.size();
			lg = __lg(n) + 2;
			t.assign(n, vector<T>(lg));

			for (int i = 0; i < n; i++) {
				t[i][0] = v[i];
			}
			for (int k = 1; k < lg; k++) {
				for (int i = 0; i + (1 << k) - 1 < n; i++) {
					t[i][k] = f(t[i][k - 1], t[i + (1 << (k - 1))][k - 1]);
				}
			}
		}
		T get(int l, int r) { 
			assert(l >= 0 && l <= r && r < n);
			int k = __builtin_clz(1) - __builtin_clz(r - l + 1);
			//int k = __builtin_clzll(1) - __builtin_clzll(r - l + 1);
			return f(t[l][k], t[r - (1 << k) + 1][k]);
		}
	};

	// Suffix Array, build -> O(n*log(n)), lcp -> O(n)
	// Numbrer of differents substrings = (n^2 + n) / 2 - sum(lcp)
	struct SuffixArray {
		int n;
		string s;
		vector<int> sa, lcp, rnk;
		SparseTable<int> t;

		SuffixArray(const string &_s, const int char_bound = 256) {
			n = _s.size();
			s = _s;
			suffix_array(s + '$', char_bound);
			build_lcp(s, sa);
			t.build(lcp);
		}

		void suffix_array(const string &s, const int char_bound) {
			int n = s.size();
			sa.resize(n);

			if (char_bound != -1) {
				vector<int> aux(char_bound, 0);
				for (int i = 0; i < n; i++) {
					aux[s[i]]++;
				}
				int sum = 0;
				for (int i = 0; i < char_bound; i++) {
					int add = aux[i];
					aux[i] = sum;
					sum += add;
				}
				for (int i = 0; i < n; i++) {
					sa[aux[s[i]]++] = i;
				}
			} 
			else {
				iota(sa.begin(), sa.end(), 0);
				sort(sa.begin(), sa.end(), [&s](int i, int j) { 
					return s[i] < s[j]; 
				});
			}

			vector<int> sorted_by_second(n);
			vector<int> ptr_group(n);
			vector<int> new_group(n);
			vector<int> group(n);
			group[sa[0]] = 0;
			for (int i = 1; i < n; i++) {
				group[sa[i]] = group[sa[i - 1]] + (!(s[sa[i]] == s[sa[i - 1]]));
			}
			int cnt = group[sa[n - 1]] + 1;
			int step = 1;
			while (cnt < n) {
				int at = 0;
				for (int i = n - step; i < n; i++) {
					sorted_by_second[at++] = i;
				}
				for (int i = 0; i < n; i++) {
					if (sa[i] - step >= 0) {
						sorted_by_second[at++] = sa[i] - step;
					}
				}
				for (int i = n - 1; i >= 0; i--) {
					ptr_group[group[sa[i]]] = i;
				}
				for (int i = 0; i < n; i++) {
					int x = sorted_by_second[i];
					sa[ptr_group[group[x]]++] = x;
				}
				new_group[sa[0]] = 0;
				for (int i = 1; i < n; i++) {
					if (group[sa[i]] != group[sa[i - 1]]) {
						new_group[sa[i]] = new_group[sa[i - 1]] + 1;
					} 
					else {
						int pre = (sa[i - 1] + step >= n ? -1 : group[sa[i - 1] + step]);
						int cur = (sa[i] + step >= n ? -1 : group[sa[i] + step]);
						new_group[sa[i]] = new_group[sa[i - 1]] + (pre != cur);
					}
				}
				swap(group, new_group);
				cnt = group[sa[n - 1]] + 1;
				step <<= 1;
			}
			sa.erase(sa.begin());
		}

		void build_lcp(const string &s, const vector<int> &sa) {
			int n = s.size();
			assert((int)sa.size() == n);
			lcp.resize(max(n - 1, 0));
			rnk.resize(n);

			for (int i = 0; i < n; i++) {
				rnk[sa[i]] = i;
			}
			int k = 0;
			for (int i = 0; i < n; i++) {
				k = max(k - 1, 0);
				if (rnk[i] == n - 1) {
					k = 0;
				} 
				else {
					int j = sa[rnk[i] + 1];
					while (i + k < n && j + k < n && s[i + k] == s[j + k]) {
						k++;
					}
					lcp[rnk[i]] = k;
				}
			}
		}   

		// O(|t|*log(n))
		int lower_bound(const string &t) {
			int l = 0, h = n - 1, ind = n;
			while (l <= h) {
				int mid = (l + h) >> 1;
				bool ok = true;
				for (int i = 0; i < (int)t.size(); i++) {
					if (sa[mid] + i >= n) {
						ok = false;
						break;
					}
					if (s[sa[mid] + i] != t[i]) {
						if (s[sa[mid] + i] < t[i]) {
							ok = false;
						}
						break;
					}
				}
				if (ok) {
					ind = mid;
					h = mid - 1;
				}
				else {
					l = mid + 1;
				}
			}
			return ind;
		}

		int upper_bound(const string &t) {
			int l = 0, h = n - 1, ind = n;
			while (l <= h) {
				int mid = (l + h) >> 1;
				bool ok = false;
				for (int i = 0; i < (int)t.size(); i++) {
					if (sa[mid] + i >= n) {
						break;
					}
					if (s[sa[mid] + i] != t[i]) {
						if (s[sa[mid] + i] > t[i]) {
							ok = true;
						}
						break;
					}
				}
				if (ok) {
					ind = mid;
					h = mid - 1;
				}
				else {
					l = mid + 1;
				}
			}
			return ind;
		}

		// Occurrences of s[p, ..., p + len - 1], O(log(n))
		pair<int, int> find_occurrence(int p, int len) {
			p = rnk[p];
			pair<int, int> ans = {p, p};
			int l = 0, r = p - 1;
			while (l <= r) {
				int mid = (l + r) >> 1;
				if (t.get(mid, p - 1) >= len) {
					ans.first = mid; 
					r = mid - 1;
				}
				else {
					l = mid + 1;
				}
			}
			l = p + 1, r = n - 1;
			while (l <= r) {
				int mid = (l + r) >> 1;
				if (t.get(p, mid - 1) >= len) {
					ans.second = mid; 
					l = mid + 1;
				}
				else {
					r = mid - 1;
				}
			}
			return ans;
		}
	};
	${0}

snippet mint "Struct Modular" 
	// constexpr int MOD = 998244353;
	constexpr int MOD = 1000000007;

	struct mint {
		int64_t v; 
		explicit operator int() const { return v; }
		explicit operator int64_t() const { return v; }
		mint() { v = 0; }
		mint(int64_t _v) {
			v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;
			if (v < 0) v += MOD;
		}

		friend bool operator == (const mint &a, const mint &b) { return a.v == b.v; }
		friend bool operator != (const mint &a, const mint &b) { return !(a == b); }
		friend bool operator < (const mint &a, const mint &b) { return a.v < b.v; }
		friend bool operator > (const mint &a, const mint &b) { return a.v > b.v; }
		friend bool operator <= (const mint &a, const mint &b) { return a.v <= b.v; }
		friend bool operator >= (const mint &a, const mint &b) { return a.v >= b.v; }

		friend mint operator + (mint a, const mint &b) { return a += b; }
		friend mint operator - (mint a, const mint &b) { return a -= b; }
		friend mint operator * (mint a, const mint &b) { return a *= b; }
		friend mint operator / (mint a, const mint &b) { return a /= b; }
		mint& operator += (const mint &m) { if ((v += m.v) >= MOD) v -= MOD; return *this; }
		mint& operator -= (const mint &m) { if ((v -= m.v) < 0) v += MOD; return *this; }
		mint& operator *= (const mint &m) { v = v * m.v % MOD; return *this; }
		mint& operator /= (const mint &m) { return (*this) *= inv(m); }

		mint operator - () const { return mint(-v); }
		mint& operator ++ () { return *this += 1; }
		mint& operator -- () { return *this -= 1; }
		mint operator ++ (int) { mint temp; temp.v = v++; return temp; }
		mint operator -- (int) { mint temp; temp.v = v--; return temp; }

		friend mint pow(mint a, int64_t b) {
			assert(b >= 0);
			mint res = 1;
			while (b) {
				if (b & 1) {
					res *= a;
				}
				a *= a;
				b >>= 1;
			}
			return res;
		}
		friend mint inv(const mint &a) {
			assert(a.v != 0);
			return pow(a, MOD - 2);
		}

		friend ostream& operator << (ostream &os, const mint &m) {
			os << m.v; 
			return os;
		}
		friend istream& operator >> (istream &is, mint &m) {
			int64_t x; 
			is >> x;
			m.v = x;
			return is;
		}
	};
	void print(mint x) { cerr << x; }
	${0}

snippet comb "Factorial & Combination & Permutaiton"
	mint fact[N];
	mint fact_inv[N];

	void init_fact(int n) {
		fact[0] = 1;
		for (int i = 1; i < n; i++) {
			fact[i] = fact[i - 1] * i;
		}
		fact_inv[n - 1] = inv(fact[n - 1]);
		for (int i = n - 2; i >= 0; i--) {
			fact_inv[i] = fact_inv[i + 1] * (i + 1);
		}
	}

	mint comb(int n, int k) {
		if (k < 0 || k > n) {
			return 0;
		}
		return fact[n] * fact_inv[k] * fact_inv[n - k];
	}

	mint perm(int n, int k) {
		if (k < 0 || k > n) {
			return 0;
		}
		return fact[n] * fact_inv[n - k];
	}
	${0}

snippet matrix "Struct Matrix" 
	template <typename T>
	struct matrix {
		int n, m;
		vector<vector<T>> mat;

		matrix() : n(0), m(0) {}
		matrix(int _n, int _m) {
			n = _n; 
			m = _m; 
			mat.assign(n, vector<T>(m, 0));
		}
		matrix(int _n, int _m, const T &val) {
			n = _n; 
			m = _m; 
			mat.assign(n, vector<T>(m, val));
		}
		matrix(vector<vector<T>> v) {
			n = v.size(); 
			m = v[0].size();
			mat = v;
		}

		inline void make_unit() {
			assert(n == m);
			for (int i = 0; i < n; i++)  {
				for (int j = 0; j < n; j++) {
					mat[i][j] = (i == j);
				}
			}
		}

		inline matrix operator + (const matrix &b) {
			assert(n == b.n && m == b.m);
			matrix res = (n, m);
			for(int i = 0; i < n; i++) {
				for(int j = 0; j < m; j++) {
					res.mat[i][j] = mat[i][j] + b.mat[i][j];
				}
			}
			return res; 
		} 
		inline matrix operator - (const matrix &b) {
			assert(n == b.n && m == b.m);
			matrix res = matrix(n, m);
			for(int i = 0; i < n; i++) {
				for(int j = 0; j < m; j++) {
					res.mat[i][j] = mat[i][j] - b.mat[i][j];
				}
			}
			return res;
		}
		inline matrix operator * (const matrix &b) {
			assert(m == b.n);
			matrix res = matrix(n, b.m);
			for(int i = 0; i < n; i++) {
				for(int j = 0; j < b.m; j++) {
					for(int k = 0; k < m; k++) {
						res.mat[i][j] += mat[i][k] * b.mat[k][j];
					}
				}
			}
			return res;
		}
		inline matrix pow(matrix a, int64_t b) {
			assert(n == m);
			matrix res(n, n); 
			res.make_unit();
			while (b) {
				if (b & 1) {
					res *= a;
				}
				a *= a;
				b >>= 1;
			}
			return res;
		}

		inline matrix& operator += (const matrix &b) { return *this = (*this) + b; }
		inline matrix& operator -= (const matrix &b) { return *this = (*this) - b; }
		inline matrix& operator *= (const matrix &b) { return *this = (*this) * b; }
		inline bool operator == (const matrix &b) { return mat == b.mat; }
		inline bool operator != (const matrix &b) { return mat != b.mat; }
	};
	${0}

snippet sieve "Sieve of Eratosthenes" 
	vector<int> primes, min_factor;
	void sieve(int n) {
		min_factor.resize(n, 0);
		min_factor[1] = 1;
		for (int i = 2; i < n; i++) {
			if (min_factor[i] == 0) {
				primes.push_back(i);
				min_factor[i] = i;
			}
			for (int j = 0; j < (int)primes.size() && i * primes[j] < n && primes[j] <= min_factor[i]; j++) {
				min_factor[i * primes[j]] = primes[j];
			}
		}
	}
	${0}

snippet segmented_sieve "Segmented Sieve of Eratosthenes" 
	bitset<N> is_prime; // is_prime._Find_next(p); is_prime._Find_first();
	void segmented_sieve(int n) {
		int sq = sqrt(n) + 1;
		is_prime[0] = is_prime[1] = 1;
		vector<array<int, 2>> small_primes;
		for (int i = 2; i <= sq; i++) {
			if (!is_prime[i]) {
				small_primes.push_back({i, i * i});
				for (int j = i * i; j <= sq; j += i) {
					is_prime[j] = 1;
				}
			}
		}

		const int block_size = 1 << 18;
		for (int from = 0; from < n; from += block_size) {
			int to = min(from + block_size - 1, n - 1);
			for (array<int, 2> &p : small_primes) {
				for (; p[1] <= to; p[1] += p[0]) {
					is_prime[p[1]] = 1;
				}
			}
		}
		is_prime.flip();
	}
	${0}

snippet miller_rabin "Miller Rabin (Check a Numbes is Prime)"
	using u128 = __uint128_t;
	int64_t binpow(int64_t a, int64_t b, int64_t m) {
		int64_t res = 1;
		a %= m;
		while (b) {
			if (b & 1) {
				res = (u128)res * a % m;
			}
			a = (u128)a * a % m;
			b >>= 1;
		}
		return res;
	}

	bool check_composite(int64_t n, int64_t a, int64_t d, int s) {
		int64_t x = binpow(a, d, n);
		if (x == 1 || x == n - 1) {
			return false;
		}
		for (int r = 1; r < s; r++) {
			x = (u128)x * x % n;
			if (x == n - 1) {
				return false;
			}
		}
		return true;
	}

	bool miller_rabin(int64_t n) { // returns true if n is prime
		if (n < 2) {
			return false;
		}

		int r = 0;
		int64_t d = n - 1;
		while ((d & 1) == 0) {
			d >>= 1;
			r++;
		}

		for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
			if (n == a) {
				return true;
			}
			if (check_composite(n, a, d, r)) {
				return false;
			}
		}
		return true;
	}
	${0}

snippet convert_base "Cnovert Base [2-36]" 
	int64_t convert_to_10(const string &input, int base) {
		assert(base >= 2 && base <= 36);
		
		bool is_neg = (input[0] == '-'); 
		int start = input.length() - 1;
		int end = is_neg ? 1 : 0;

		int64_t res = 0, digit_value = 1;
		for(int i = start; i >= end; i--) {
			char c = input[i];
			
			if (c >= '0' && c <= '9') {
				c -= '0';
			}
			else {
				c = c - 'A' + 10;
			}
			assert(c < base);
			
			res += c * digit_value;
			digit_value *= base;
		}
		
		if (is_neg) {
			res *= -1;
		}
		
		return res;
	}

	string convert_from_10(int64_t value, int base) {
		assert(base >= 2 && base <= 36);
		
		bool is_neg = (value < 0);
		if (is_neg) {
			value *= -1;
		}
		
		string res;
		do {
			char digit = value % base;
		 
			if (digit < 10) {
				digit += '0';
			}
			else {
				digit = digit + 'A' - 10;
			}
			res += digit;
			value /= base;
			
		} while (value > 0);
		
		if (is_neg) {
			res += '-';
		}
		reverse(res.begin(), res.end());

		return res;
	}

	string convert_base(const string input, int base_from, int base_to) {
		return convert_from_10(convert_to_10(input, base_from), base_to);
	}
	${0}

snippet pw "Binary Exponentiation"
	int64_t pw(int64_t a, int64_t b){
		assert(b >= 0);
		int64_t res = 1;
		while (b) {
			if (b & 1) {
				res *= a;
			}
			a *= a;
			b >>= 1;
		}
		return res;
	}
	${0}

snippet table "Geometry Movement" 
    constexpr int dx[] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};
    constexpr int dy[] = {0, 0, -1, 1, -1, 1, -1, 1, 0};
    auto check = [&](int x, int y) -> bool {
        return x >= 0 && x < n && y >= 0 && y < m;
    };
	${0}

snippet geo2d "Geometry 2D"
	const ld inf = 1e100;
	const ld eps = 1e-9;
	const ld PI = acos(ld(-1.0));

	int sign(ld x) {
		return (x > eps) - (x < -eps);
	}

	struct PT {
		ld x, y;

		PT() : x(0), y(0) {}
		PT(ld x, ld y) : x(x), y(y) {}
		PT(const PT &p) : x(p.x), y(p.y) {}

		PT operator + (const PT &p) const { return PT(x + p.x, y + p.y); }
		PT operator - (const PT &p) const { return PT(x - p.x, y - p.y); }
		PT operator * (const ld a) const { return PT(x * a, y * a); }
		friend PT operator * (const ld &a, const PT &p) { return PT(a * p.x, a * p.y); }
		PT operator / (const ld a) { return PT(x / a, y / a); }

		bool operator == (PT p) const { return sign(p.x - x) == 0 && sign(p.y - y) == 0; }
		bool operator != (PT p) const { return !(*this == p); }
		bool operator < (PT p) const { return sign(p.x - x) == 0 ? y < p.y : x < p.x; }
		bool operator > (PT p) const { return sign(p.x - x) == 0 ? y > p.y : x > p.x; }
		bool operator <= (PT p) const { return (*this < p) || (*this == p); }
		bool operator >= (PT p) const { return (*this > p) || (*this == p); }

		ld norm() { return sqrt(x * x + y * y); }
		ld norm2() { return x * x + y * y; }

		PT perp() { return PT(-y, x); }
		ld arg() { return atan2(y, x); }

		PT truncate(ld r) { // returns a vector with norm r and having same direction
			ld k = norm();
			if (!sign(k)) return *this;
			r /= k;
			return PT(x * r, y * r);
		}
	};

	istream &operator >> (istream &in, PT &p) { return in >> p.x >> p.y; }
	ostream &operator << (ostream &out, PT &p) { return out << "(" << p.x << "," << p.y << ")"; }

	inline ld dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }
	inline ld dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }
	inline ld dist2(PT a, PT b) { return dot(a - b, a - b); }
	inline ld cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }
	inline ld cross2(PT a, PT b, PT c) { return cross(b - a, c - a); }
	inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }

	PT perp(PT a) { return PT(-a.y, a.x); }
	PT rotateccw90(PT a) { return PT(-a.y, a.x); }
	PT rotatecw90(PT a) { return PT(a.y, -a.x); }
	PT rotateccw(PT a, ld t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t)); }
	PT rotatecw(PT a, ld t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t)); }
	ld SQ(ld x) { return x * x; }
	ld rad_to_deg(ld r) { return (r * 180.0 / PI); }
	ld deg_to_rad(ld d) { return (d * PI / 180.0); }

	ld get_angle(PT a, PT b) {
		ld costheta = dot(a, b) / a.norm() / b.norm();
		return acos(max((ld)-1.0, min((ld)1.0, costheta)));
	}

	bool is_point_in_angle(PT b, PT a, PT c, PT p) { // does point p lie in angle <bac
		assert(orientation(a, b, c) != 0);
		if (orientation(a, c, b) < 0) swap(b, c);
		return orientation(a, c, p) >= 0 && orientation(a, b, p) <= 0;
	}

	bool half(PT p) {
		return p.y > 0.0 || (p.y == 0.0 && p.x < 0.0);
	}

	void polar_sort(vector<PT> &v) { // sort points in counterclockwise
		sort(v.begin(), v.end(), [](PT a,PT b) {
			return make_tuple(half(a), 0.0, a.norm2()) < make_tuple(half(b), cross(a, b), b.norm2());
		});
	}

	void polar_sort(vector<PT> &v, PT o) { // sort points in counterclockwise with respect to point o
		sort(v.begin(), v.end(), [&](PT a,PT b) {
			return make_tuple(half(a - o), 0.0, (a - o).norm2()) < make_tuple(half(b - o), cross(a - o, b - o), (b - o).norm2());
		});
	}

	struct line {
		PT a, b; // goes through points a and b
		PT v; ld c;  //line form: direction vec [cross] (x, y) = c 

		line() {}
		//direction vector v and offset c
		line(PT v, ld c) : v(v), c(c) {
			auto p = get_points();
			a = p.first; b = p.second;
		}
		// equation ax + by + c = 0
		line(ld _a, ld _b, ld _c) : v({_b, -_a}), c(-_c) {
			auto p = get_points();
			a = p.first; b = p.second;
		}
		// goes through points p and q
		line(PT p, PT q) : v(q - p), c(cross(v, p)), a(p), b(q) {}

		//extract any two points from this line
		pair<PT, PT> get_points() {
			PT p, q; ld a = -v.y, b = v.x; // ax + by = c
			if (sign(a) == 0) {
				p = PT(0, c / b);
				q = PT(1, c / b);
			}
			else if (sign(b) == 0) {
				p = PT(c / a, 0);
				q = PT(c / a, 1);
			}
			else {
				p = PT(0, c / b);
				q = PT(1, (c - a) / b);
			}
			return {p, q};
		}

		// ax + by + c = 0
		array<ld, 3> get_abc() {
			ld a = -v.y, b = v.x;
			return {a, b, -c};
		}

		// 1 if on the left, -1 if on the right, 0 if on the line
		int side(PT p) { return sign(cross(v, p) - c); }

		// line that is perpendicular to this and goes through point p
		line perpendicular_through(PT p) { return {p, p + perp(v)}; }

		// translate the line by vector t i.e. shifting it by vector t
		line translate(PT t) { return {v, c + cross(v, t)}; }

		// compare two points by their orthogonal projection on this line
		// a projection point comes before another if it comes first according to vector v
		bool cmp_by_projection(PT p, PT q) { return dot(v, p) < dot(v, q); }

		line shift_left(ld d) {
			PT z = v.perp().truncate(d);
			return line(a + z, b + z);
		}
	};

	// find a point from a through b with distance d
	PT point_along_line(PT a, PT b, ld d) {
		assert(a != b);
		return a + (((b - a) / (b - a).norm()) * d);
	}

	// projection point c onto line through a and b  assuming a != b
	PT project_from_point_to_line(PT a, PT b, PT c) {
		return a + (b - a) * dot(c - a, b - a) / (b - a).norm2();
	}

	// reflection point c onto line through a and b  assuming a != b
	PT reflection_from_point_to_line(PT a, PT b, PT c) {
		PT p = project_from_point_to_line(a, b, c);
		return p + p - c;
	}

	// minimum distance from point c to line through a and b
	ld dist_from_point_to_line(PT a, PT b, PT c) {
		return fabs(cross(b - a, c - a) / (b - a).norm());
	}

	// returns true if  point p is on line segment ab
	bool is_point_on_seg(PT a, PT b, PT p) {
		if (fabs(cross(p - b, a - b)) < eps) {
			if (p.x < min(a.x, b.x) - eps || p.x > max(a.x, b.x) + eps) return false;
			if (p.y < min(a.y, b.y) - eps || p.y > max(a.y, b.y) + eps) return false;
			return true;
		}
		return false;
	}

	// minimum distance point from point c to segment ab that lies on segment ab
	PT project_from_point_to_seg(PT a, PT b, PT c) {
		ld r = dist2(a, b);
		if (sign(r) == 0) return a;
		r = dot(c - a, b - a) / r;
		if (r < 0) return a;
		if (r > 1) return b;
		return a + (b - a) * r;
	}

	// minimum distance from point c to segment ab
	ld dist_from_point_to_seg(PT a, PT b, PT c) {
		return dist(c, project_from_point_to_seg(a, b, c));
	}

	// 0 if not parallel, 1 if parallel, 2 if collinear
	int is_parallel(PT a, PT b, PT c, PT d) {
		ld k = fabs(cross(b - a, d - c));
		if (k < eps){
			if (fabs(cross(a - b, a - c)) < eps && fabs(cross(c - d, c - a)) < eps) return 2;
			else return 1;
		}
		else return 0;
	}

	// check if two lines are same
	bool are_lines_same(PT a, PT b, PT c, PT d) {
		if (fabs(cross(a - c, c - d)) < eps && fabs(cross(b - c, c - d)) < eps) return true;
		return false;
	}

	// bisector vector of <abc
	PT angle_bisector(PT &a, PT &b, PT &c){
		PT p = a - b, q = c - b;
		return p + q * sqrt(dot(p, p) / dot(q, q));
	}

	// 1 if point is ccw to the line, 2 if point is cw to the line, 3 if point is on the line
	int point_line_relation(PT a, PT b, PT p) {
		int c = sign(cross(p - a, b - a));
		if (c < 0) return 1;
		if (c > 0) return 2;
		return 3;
	}

	// intersection point between ab and cd assuming unique intersection exists
	bool line_line_intersection(PT a, PT b, PT c, PT d, PT &ans) {
		ld a1 = a.y - b.y, b1 = b.x - a.x, c1 = cross(a, b);
		ld a2 = c.y - d.y, b2 = d.x - c.x, c2 = cross(c, d);
		ld det = a1 * b2 - a2 * b1;
		if (det == 0) return 0;
		ans = PT((b1 * c2 - b2 * c1) / det, (c1 * a2 - a1 * c2) / det);
		return 1;
	}

	// intersection point between segment ab and segment cd assuming unique intersection exists
	bool seg_seg_intersection(PT a, PT b, PT c, PT d, PT &ans) {
		ld oa = cross2(c, d, a), ob = cross2(c, d, b);
		ld oc = cross2(a, b, c), od = cross2(a, b, d);
		if (oa * ob < 0 && oc * od < 0){
			ans = (a * ob - b * oa) / (ob - oa);
			return 1;
		}
		else return 0;
	}

	// intersection point between segment ab and segment cd assuming unique intersection may not exists
	// se.size()==0 means no intersection
	// se.size()==1 means one intersection
	// se.size()==2 means range intersection
	set<PT> seg_seg_intersection_inside(PT a,  PT b,  PT c,  PT d) {
		PT ans;
		if (seg_seg_intersection(a, b, c, d, ans)) return {ans};
		set<PT> se;
		if (is_point_on_seg(c, d, a)) se.insert(a);
		if (is_point_on_seg(c, d, b)) se.insert(b);
		if (is_point_on_seg(a, b, c)) se.insert(c);
		if (is_point_on_seg(a, b, d)) se.insert(d);
		return se;
	}

	// intersection  between segment ab and line cd
	// 0 if do not intersect, 1 if proper intersect, 2 if segment intersect
	int seg_line_relation(PT a, PT b, PT c, PT d) {
		ld p = cross2(c, d, a);
		ld q = cross2(c, d, b);
		if (sign(p) == 0 && sign(q) == 0) return 2;
		else if (p * q < 0) return 1;
		else return 0;
	}

	// intersection between segament ab and line cd assuming unique intersection exists
	bool seg_line_intersection(PT a, PT b, PT c, PT d, PT &ans) {
		bool k = seg_line_relation(a, b, c, d);
		assert(k != 2);
		if (k) line_line_intersection(a, b, c, d, ans);
		return k;
	}

	// minimum distance from segment ab to segment cd
	ld dist_from_seg_to_seg(PT a, PT b, PT c, PT d) {
		PT dummy;
		if (seg_seg_intersection(a, b, c, d, dummy)) return 0.0;
		else return min({dist_from_point_to_seg(a, b, c), dist_from_point_to_seg(a, b, d), 
			dist_from_point_to_seg(c, d, a), dist_from_point_to_seg(c, d, b)});
	}

	// minimum distance from point c to ray (starting point a and direction vector b)
	ld dist_from_point_to_ray(PT a, PT b, PT c) {
		b = a + b;
		ld r = dot(c - a, b - a);
		if (r < 0.0) return dist(c, a);
		return dist_from_point_to_line(a, b, c);
	}

	// starting point as and direction vector ad
	bool ray_ray_intersection(PT as, PT ad, PT bs, PT bd) {
		ld dx = bs.x - as.x, dy = bs.y - as.y;
		ld det = bd.x * ad.y - bd.y * ad.x;
		if (fabs(det) < eps) return 0;
		ld u = (dy * bd.x - dx * bd.y) / det;
		ld v = (dy * ad.x - dx * ad.y) / det;
		if (sign(u) >= 0 && sign(v) >= 0) return 1;
		else return 0;
	}

	ld ray_ray_distance(PT as, PT ad, PT bs, PT bd) {
		if (ray_ray_intersection(as, ad, bs, bd)) return 0.0;
		ld ans = dist_from_point_to_ray(as, ad, bs);
		ans = min(ans, dist_from_point_to_ray(bs, bd, as));
		return ans;
	}
	${0}

snippet arpa "Offline RMQ (Arpa's Trick), O(n + q)"
    vector<vector<array<int, 2>>> queries(n);
    for (int i = 0; i < q; i++) {
        int l, r;
        cin >> l >> r;
        l--, r--;
        queries[r].push_back({l, i});
    }

    vector<int> par(n, -1);
    auto find_set = [&](auto &&self, int v) -> int {
        return par[v] == -1 ? v : par[v] = self(self, par[v]);
    };

    vector<int> ans(q);
    stack<int> s;
    for (int i = 0; i < n; i++) {
        while (!s.empty() && a[s.top()] > a[i]) {
            par[s.top()] = i;
            s.pop();
        }
        s.push(i);
        for (auto [l, ind] : queries[i]) {
            ans[ind] = a[find_set(find_set, l)];
        }
    }

